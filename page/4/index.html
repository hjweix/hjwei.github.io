<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="HJW"><meta name="copyright" content="HJW"><title>HJW</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3a101c3aa7d1cde834d9d6b197500902";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-139524382-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/17232182?s=460&amp;v=4"></div><div class="author-info__name text-center">HJW</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/hjwjw">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">88</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">62</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">22</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HJW</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">HJW</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/posts/41733482/">Spring Boot环境下的 H2数据库基本配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/H2/">H2</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/H2/">H2</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spring-Boot/">Spring Boot</a></span><div class="content"><p><strong>目录</strong></p>
<p>[TOC]</p>
<hr>
<h1 id="一、H2介绍"><a href="#一、H2介绍" class="headerlink" title="一、H2介绍"></a>一、H2介绍</h1><p>H2是一个开源的、纯Java实现的关系数据库。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>1、它可以与应用程序打包一起发布，这样可以很方便存储少量的结构化数据。<br>2、还可以用于单元测试，启动速度快，而且可以关闭持久化功能，每一个用例执行完随即还原到初始状态<br>3、可以作为缓存，作为NoSQL的一个补充。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、纯Java编写，不受平台限制<br>2、只有一个Jar文件，适合作为嵌入式数据库使用<br>3、提供了一个完善的基于浏览器的Console应用<br>4、支持标准的sql和jdbc<br>5、支持内嵌模式，服务器模式和集群</p>
<h1 id="二、下载安装"><a href="#二、下载安装" class="headerlink" title="二、下载安装"></a>二、下载安装</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><pre><code>http://www.h2database.com/html/main.html
</code></pre><p><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4o0mxjoj30n00cbdh1.jpg" alt="H2下载"><br>我们可以下载win安装包，也可以直接下载zip，解压即用。我使用的是ZIP的压缩包。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>前面我们说过H2是纯Java编写的，所以在安装H2之前需要配置Java环境，具体Java环境配置这里就不写了。<br>H2的ZIP安装方式很简单，直接把下载下来的ZIP解压到安装目录下就可以了。<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nzyys7j30gu05qwet.jpg" alt="这里写图片描述"><br>启动H2 bin/h2.bat</p>
<h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><p>在Spring Boot环境中配置H2</p>
<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>这里还引入了jpa 用来对H2进行操作</p>
<h2 id="服务器模式"><a href="#服务器模式" class="headerlink" title="服务器模式"></a>服务器模式</h2><p><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4o0a4uij30ej0a6t9b.jpg" alt="配置H2"><br>其中URL使用的形式表示这里使用的是H2的服务器模式。连接的是我们上面安装的本地的H2数据库，因此我们在启动程序前必须把本地的H2数据库先启动。<br>URL中指定了数据存放位置，如果数据库test不存在会自动创建。<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4o07b6wj30h706baah.jpg" alt="创建数据库"></p>
<blockquote>
<p>配置中指定两个SQL脚本，每次启动程序都会重新执行脚本对数据进行初始化，当然我们可以不指定。<br>schema.sql 创建了一个user表结构<br>data.sql 向user表插入了三条数据</p>
</blockquote>
<p><strong>查看Console</strong><br>在前面启动H2数据库的时候会自动弹出consol管理页，按程序中指定的URL进行连接即可查看到我们创建的数据<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4o0dnwgj30l40c8wf5.jpg" alt="这里写图片描述"><br>用户名 sa 是默认的用户，密码默认为空。<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4o0364fj30nc0cpwfm.jpg" alt="这里写图片描述"><br>登入进Console后我们可以查看user表</p>
<p>在配置文件中配置了Web Console的路径，同样我们可以使用这个路径进行登入。</p>
<h2 id="内嵌模式"><a href="#内嵌模式" class="headerlink" title="内嵌模式"></a>内嵌模式</h2><p>H2最方便的是只需要一个jar包就可以使用了。前面我们引入H2依赖后其它就可以使用H2了，不需要连接我们本地安装的H2。<br>可以直接不指定URL<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4o0psowj30f008pgm3.jpg" alt="这里写图片描述"><br>或者修改一URL为：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4o0h0m4j30d203wmxb.jpg" alt="这里写图片描述"><br>我们可以使用Web Console连接,连接的url为 </p>
<pre><code>jdbc:h2:mem:testdb
</code></pre><blockquote>
<p>当我们没有指定URL的时候，默认的连接的数据库也是testdb 之前看教程说在把日志改成DEBUG可以看到连接的URL，但我试了还是没有找到，只只根据教程上的URL也连接，确定连接上了对应的数据库</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/4e556baf/">redis 常用命令记录</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/redis/">redis</a></span><div class="content"><h3 id="打开redis命令窗口"><a href="#打开redis命令窗口" class="headerlink" title="打开redis命令窗口"></a>打开redis命令窗口</h3><pre><code>./redis-cli
</code></pre><h3 id="清空当前redis数据库缓存FLUSHDB"><a href="#清空当前redis数据库缓存FLUSHDB" class="headerlink" title="清空当前redis数据库缓存FLUSHDB"></a>清空当前redis数据库缓存FLUSHDB</h3><pre><code>flushdb
</code></pre><h3 id="清空整个redis缓存FLUSHALL"><a href="#清空整个redis缓存FLUSHALL" class="headerlink" title="清空整个redis缓存FLUSHALL"></a>清空整个redis缓存FLUSHALL</h3><pre><code>flushall
</code></pre><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><pre><code>vim  /etc/redis.conf
#requirepass foobared去掉注释，foobared改为自己的密码，我在这里改为
requirepass 123456
然后保存，重启服务
</code></pre><h3 id="登陆redis"><a href="#登陆redis" class="headerlink" title="登陆redis"></a>登陆redis</h3><pre><code>auth password
</code></pre><h3 id="Jedis连接redis"><a href="#Jedis连接redis" class="headerlink" title="Jedis连接redis"></a>Jedis连接redis</h3><p><strong>java 代码方式</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连接redis服务器，192.168.0.100:6379</span></span><br><span class="line"> jedis = <span class="keyword">new</span> Jedis(<span class="string">"ip"</span>, <span class="number">6379</span>);</span><br><span class="line"> <span class="comment">//权限认证</span></span><br><span class="line">jedis.auth(<span class="string">"password"</span>);</span><br></pre></td></tr></table></figure></p>
<p> <strong>配置文件方式</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”jedisConnectionFactory”</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">”org.springframework.data.redis.connection.jedis.JedisConnectionFactory”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">”hostName”</span> <span class="attr">value</span>=<span class="string">”$&#123;redis.host&#125;”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">”port”</span> <span class="attr">value</span>=<span class="string">”$&#123;redis.port&#125;”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">”password”</span> <span class="attr">value</span>=<span class="string">”$&#123;redis.pass&#125;”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="关闭redis"><a href="#关闭redis" class="headerlink" title="关闭redis"></a>关闭redis</h3><pre><code>[root@iZ94jzcra1hZ bin]# pkill redis
</code></pre><h3 id="后台开启redis："><a href="#后台开启redis：" class="headerlink" title="后台开启redis："></a>后台开启redis：</h3><pre><code>[root@iZ94jzcra1hZ bin]# redis-server &amp;
加&amp;符号的作用是为了让此进程转换为后台进程，不占用shell的服务。
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/d72bda77/">RabbitMQ学习系列 五 RabbitMQ整合Spring</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-05-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MQ/">MQ</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></span><div class="content"><p>最后学习一下RabbitMQ如何整合Spring，毕竟现在大多是使用框架来做项目。这篇主要使用的方式是XML配置。</p>
<p>[TOC]</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>RabbitMQ整合Spring的学习中，搭了两个web项目，一个作为客户端，一个作为服务端，放在一个项目中也可以实现效果，但毕竟RabbitMQ也是在这种类似的环境中使用的。客户端会把info类型和error类型的日志发送给RabbitMQ，RabbitMQ根据所定义的路由与绑定的key分别把日志消息传递给不同的队列。<br>客户端项目结构:<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nmj04gj308x09cdg0.jpg" alt="rabbitmq整合Spring项目结构"></p>
<h1 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h1><h2 id="RabbitMQ配置文件"><a href="#RabbitMQ配置文件" class="headerlink" title="RabbitMQ配置文件"></a>RabbitMQ配置文件</h2><p><strong>config.properties</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># RabbitMQ config</span><br><span class="line">rabbitmq.host=localhost</span><br><span class="line">rabbitmq.username=guest</span><br><span class="line">rabbitmq.password=guest</span><br><span class="line">rabbitmq.port=5672</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里在我本机的RabbitMQ，如果是在远程主机上则要做相应修改。需要注意的是，我们访问RabbitMQ管理界面是使用的<strong>15672</strong>端口，但通过连接访问RabbitMQ是使用<strong>5672</strong>端口</p>
</blockquote>
<h2 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">"http://www.springframework.org/schema/rabbit"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.7.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"</span>&gt;</span></span><br><span class="line">                           </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.rabbitmq.spring"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:config.properties"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接工厂--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">host</span>=<span class="string">"$&#123;rabbitmq.host&#125;"</span> <span class="attr">username</span>=<span class="string">"$&#123;rabbitmq.username&#125;"</span> <span class="attr">password</span>=<span class="string">"$&#123;rabbitmq.password&#125;"</span> <span class="attr">port</span>=<span class="string">"$&#123;rabbitmq.port&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:connection-factory</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitAdmin主要用于创建队列和交换器以及绑定关系等。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"rabbitAdmin"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"rabbitmq_log_info"</span> <span class="attr">durable</span>=<span class="string">"true"</span> <span class="attr">auto-delete</span>=<span class="string">"false"</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"rabbitmq_log_error"</span> <span class="attr">durable</span>=<span class="string">"true"</span> <span class="attr">auto-delete</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明路由并绑定队列，指定routingKey--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">name</span>=<span class="string">"hap.log.exchange"</span>  <span class="attr">auto-delete</span>=<span class="string">"false"</span> <span class="attr">durable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">"rabbitmq_log_info"</span> <span class="attr">key</span>=<span class="string">"info"</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">"rabbitmq_log_error"</span> <span class="attr">key</span>=<span class="string">"error"</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义RabbitTemplate，用于发送与接收消息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"rabbitTemplateLogInfo"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> <span class="attr">routing-key</span>=<span class="string">"info"</span> <span class="attr">exchange</span>=<span class="string">"hap.log.exchange"</span> <span class="attr">message-converter</span>=<span class="string">"jsonMessageConverter"</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"rabbitTemplateLogError"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> <span class="attr">routing-key</span>=<span class="string">"error"</span> <span class="attr">exchange</span>=<span class="string">"hap.log.exchange"</span> <span class="attr">message-converter</span>=<span class="string">"jsonMessageConverter"</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息对象json转换类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jsonMessageConverter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.support.converter.Jackson2JsonMessageConverter"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p> <strong>rabbit-admin</strong>  标签如不声明,则 rabbit:queue 与 rabbit:direct-exchange 标签中必须添加 auto-declare 属性为true ,表示如果队列或路由不存在则自动声明，如不声明rabbit-admin，也不添加auto-declare属性则启动时会报声明队列错误，或队列不存在。<br> <strong>rabbit:template</strong> 标签中的routing-key、exchange也可以不在XML中配置，在类中发送消息时可以作为参数代入。则XML中只需要配置一个rabbit:template标签即可</p>
</blockquote>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p><strong>Service接口</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISendMessageService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfoMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendErrorMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Service实现类</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageService</span> <span class="keyword">implements</span> <span class="title">ISendMessageService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"rabbitTemplateLogInfo"</span>)</span><br><span class="line">    <span class="keyword">public</span> RabbitTemplate rabbitTemplateLogInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"rabbitTemplateLogError"</span>)</span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplateLogError;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfoMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Info发送消息中&gt;&gt;&gt;"</span> + message);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplateLogInfo.convertAndSend(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendErrorMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Error发送消息中&gt;&gt;&gt;"</span> + message);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplateLogError.convertAndSend(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>RabbitTemplate的convertAndSend方法中，如果XML中已经配置好了对应的exchange与routingKey则可以直接传入一个消息进行发送即可。如果没有可以在参数中加入Exchange 与 routingkey</p>
</blockquote>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/rabbitmqLog"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"sendMessageService"</span>)</span><br><span class="line">    ISendMessageService service = <span class="keyword">new</span> SendMessageService();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/sendInfoLog"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfoMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        service.sendInfoMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/sendErrorLog"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendErrorMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        service.sendErrorMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h1><p>因为这里只是做一个简单的示例，所以服务端只做了监听，没有做什么业务逻辑。</p>
<h2 id="RabbitMQ配置文件-1"><a href="#RabbitMQ配置文件-1" class="headerlink" title="RabbitMQ配置文件"></a>RabbitMQ配置文件</h2><p>这里与客户端是一样的</p>
<h2 id="XML配置-1"><a href="#XML配置-1" class="headerlink" title="XML配置"></a>XML配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">"http://www.springframework.org/schema/rabbit"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.7.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.rabbitmq.spring"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath*:config.properties"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">host</span>=<span class="string">"$&#123;rabbitmq.host&#125;"</span> <span class="attr">username</span>=<span class="string">"$&#123;rabbitmq.username&#125;"</span> <span class="attr">password</span>=<span class="string">"$&#123;rabbitmq.password&#125;"</span> <span class="attr">port</span>=<span class="string">"$&#123;rabbitmq.port&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:connection-factory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">id</span>=<span class="string">"rabbitAdmin"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"rabbitmq_log_info"</span> <span class="attr">durable</span>=<span class="string">"true"</span> <span class="attr">auto-delete</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"rabbitmq_log_error"</span> <span class="attr">durable</span>=<span class="string">"true"</span> <span class="attr">auto-delete</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span> <span class="attr">acknowledge</span>=<span class="string">"auto"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">"messageRecevicer"</span> <span class="attr">queues</span>=<span class="string">"rabbitmq_log_info"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">"messageRecevicer"</span> <span class="attr">queues</span>=<span class="string">"rabbitmq_log_error"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageRecevicer"</span> <span class="attr">class</span>=<span class="string">"com.rabbitmq.spring.listener.QueueListener"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息对象json转换类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jsonMessageConverter"</span> <span class="attr">class</span>=<span class="string">"org.springframework.amqp.support.converter.Jackson2JsonMessageConverter"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>服务端的XML与客户端不同的是多了监听配置与监听类的Bean，少了路由声明与队列绑定的配置。</p>
</blockquote>
<h2 id="监听类"><a href="#监听类" class="headerlink" title="监听类"></a>监听类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg = <span class="keyword">new</span> String(message.getBody(),<span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"监听到 "</span>+ message.getMessageProperties().getConsumerQueue()+<span class="string">" 队列消息:"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>最后我们分别启动客户端与服务端。客户端调用Controller向服务端发送消息 。<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nmmad8j3116095my4.jpg" alt="测试"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/5dabf99c/">RabbitMQ学习系列 三 发布 订阅</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-05-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MQ/">MQ</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></span><div class="content"><p>[TOC]</p>
<p>上一篇记录了一个简单的rabbitmq 发布接收队列消息，但没有使用路由。本篇写一写rabbitmq的路由的使用。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>有几个概念介绍一下<br>1、生产者<br>​<br>​    生产者是发送消息的用户的应用程序</p>
<p>2、路由<br>​<br>​    处理生产者消息发到哪个队列</p>
<p>3、队列</p>
<pre><code>队列是存储消息的缓冲器
</code></pre><p>4、消费者</p>
<pre><code>消费者是接收消息的用户的应用程序
</code></pre><p><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nqtijnj30bq0483yk.jpg" alt="消息模型"></p>
<p>RabbitMQ中的消息传递模型的核心思想是生产者永远不会将任何消息直接发送到队列中。实际上，生产者通常甚至不知道消息是否会被传送到任何队列中。我们的消息实际上是从生产者传递到路由，路由会绑定队列并指定绑定的routingKey。根据routingkey匹配到这个路由上绑定的队列，并向队列发送消息，不能匹配上的队列则不会收到该消息。所以我们上一篇文章中虽然没有明确定义路由，实际上是使用是默认的路由。我们可以根据需求自己声明相应的路由。</p>
<h1 id="路由-Exchange"><a href="#路由-Exchange" class="headerlink" title="路由(Exchange)"></a>路由(Exchange)</h1><h3 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h3><pre><code>exchangeDeclare(String exchange, String type, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments)
</code></pre><blockquote>
<p>exchange :路由名<br>type : 路由类型<br>durable: 是否持久化<br>autoDelete：是否自动删除<br>arguments: 其它参数</p>
</blockquote>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>1、Fanout<br>​    &gt; 广播。这个类型的路由会忽略routingKey。收到生产者消息后会直接发送给绑定在该路由上的所有队列</p>
<p>2、Direct</p>
<blockquote>
<p>单播。该类型的路由会根据routingKey去匹配队列，将消息发送给该路由上绑定的并且routingKey完全匹配上的队列</p>
</blockquote>
<p>3、Topic</p>
<blockquote>
<p>多播。该类型路由的routingKey可以使用通配符进行匹配。即 * 代表一个单词，# 代表多个单词。routingKey 的定义不能是任意字符，只能是由点号分隔的字符串，如: “ stock.usd.nyse ”，“ nyse.vmw ”，“ quick.orange.rabbit ”。<br>如下图<br>Q1队列的与路由绑定的routingKey 是<strong><strong>.orange.</strong></strong><br>Q2队列的与路由绑定的routingKey 是 <strong><strong>.</strong></strong>.rabbit  与 lazy.#<br>如果我们发送消息时指定的routingKey为:quick.orange.rabbit ，则消息会被路由发送到Q1与Q2两个队列中。<br>如果我们发送消息时指定的routingKey为:lazy.brown.fox ，则消息会被路由发送到Q2队列<br>如果指定的routingKey为 lazy.pink.rabbit，也会被发送到Q2，但只会发送一次，即使它匹配到了两个绑定的routingKey<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nqr0t8j30bs04rt8t.jpg" alt="示例"></p>
</blockquote>
<p>4、Headers</p>
<blockquote>
<p>这种类型的路由不处理路由键，而是根据发送消息的Headers属性进行匹配，在队列绑定交换机的时候会指定一组键对值;</p>
</blockquote>
<h3 id="绑定队列"><a href="#绑定队列" class="headerlink" title="绑定队列"></a>绑定队列</h3><pre><code>queueBind(String queue, String exchange, String routingKey)
</code></pre><blockquote>
<p>前面我们说过 RabbitMQ中的消息传递模型的核心思想是生产者永远不会将任何消息直接发送到队列中。所以我们每个队列都需要绑定在一个路由上。从生产者发送到该路由的消息只会被传递到与路由绑定的队列上。绑定时还需要指定一个routingKey，路由根据发布消息时传递过来的routintKey来匹配到相应队列并传送消息到该队列中。<br>queue: 队列名<br>exchange: 路由名<br>routingKey: 队列与路由绑定的key</p>
</blockquote>
<h1 id="编写生产者"><a href="#编写生产者" class="headerlink" title="编写生产者"></a>编写生产者</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogTopic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        String message =<span class="string">"Hello World! This is error info!"</span>;</span><br><span class="line">        <span class="comment">/* 我们使用的是topic类型的路由，第二个参数为routingKey*/</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,<span class="string">"rabbit.log.error"</span>,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>发送消息时我们指定的routingKey为 rabbit.log.error 因为是topic类型的路由，所以需要用点分隔的形式写routingKey ，如果是Direct类型则不需要。</p>
</blockquote>
<h1 id="编写消费者"><a href="#编写消费者" class="headerlink" title="编写消费者"></a>编写消费者</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceivedLogsTopic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        String queuesName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">/*将队列绑定路由并定义topic类型路由的匹配规则*/</span></span><br><span class="line">        channel.queueBind(queuesName,EXCHANGE_NAME,<span class="string">"*.log.*"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body,<span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[x] recv:"</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queuesName,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里队列绑定topic 类型路由时指定的匹配规则为 <strong><strong>.log.</strong></strong><br>前面生产者发送时的routingKey 为 rabbit.log.error 所以这条消息会被路由监听到。 如果我们将绑定的匹配规则修改为 log.# 并重新启动一个消费者B，通过生产者再次发送消息，则消费者B不会监听到这条消息，因为routingKey 无法匹配上，路由不会把这条消息传递给消费者B</p>
</blockquote>
<p> <strong>* 注意在测试时是需要先启动消费者，再启动生产者。因为如果没有消费者在线，消息会被rabbitMq丢弃处理 </strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/aca91396/">RabbitMQ学习系列 二 “Hello World”</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-05-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MQ/">MQ</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></span><div class="content"><p> 前面写了RabbitMQ的安装，这一篇记录一下 “Hello World” 的实现 。</p>
<p>[TOC]</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>使用最简单的方式发布一个消息并接收<br>这里声明了一个hello队列，没有使用路由。</p>
</blockquote>
<h3 id="编写生产者"><a href="#编写生产者" class="headerlink" title="编写生产者"></a>编写生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME=<span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">/*创建连接工厂*/</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">/*创建频道*/</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">/*声明一个队列*/</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        String message = <span class="string">"HJW,Hello World!"</span>;</span><br><span class="line">        <span class="comment">/*发布消息*/</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写消费者"><a href="#编写消费者" class="headerlink" title="编写消费者"></a>编写消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME =<span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">/*创建连接工厂*/</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">/*设置Rabbitmq主机地址，用户名密码与端口。用户名密码与端口可不设置可以使用默认*/</span></span><br><span class="line">        connectionFactory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">/*通过连接创建频道*/</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">/*声明一个队列 */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">/*创建一个消费者*/</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body,<span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">" Message is received: "</span> + message );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/*订阅消息并消费*/</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><p>1、队列声明</p>
<pre><code>queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)
</code></pre><blockquote>
<p>queue:队列名称<br>durable:是否持久化<br>exclusive:是否为排它队列。即只有自己可见，对首次连接可见，连接断开自动删除<br>autoDelete:是否自动删除，在没有消费者的时候<br>arguments:其它参数</p>
</blockquote>
<p>2、发布消息</p>
<pre><code>basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body)
</code></pre><blockquote>
<p>exchange:路由名<br>routingKey:发布到哪个队列<br>props: 其它参数<br>body: 消息体</p>
</blockquote>
<p>3、订阅消息并消费</p>
<pre><code>basicConsume(String queue, boolean autoAck, Consumer callback)
</code></pre><blockquote>
<p>queue:消息队列名<br>autoAck: 是否自动确认。消息被消息后需要向rabbitmq返回一个确认，rabbitmq才会把消息删除，也可以手动确认<br>callback: 消费者</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/a7407de/">RabbitMQ学习系列 一 RabbitMQ 的安装</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MQ/">MQ</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></span><div class="content"><p>[TOC]</p>
<p>之前项目上使用到了ActiveMQ，所以学习了下ActiveMQ ，使用JMS结合ActiveMQ发送消息或主题，大致了解了它的使用。听说RabbitMQ 才是主流，，打算学习RabbitMQ。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。消息中间件主要用于组件之间的解耦。rabbitmq多应用于批量数据异步处理、并行任务串行化，高负载任务的负载均衡等 重量级，高并发，异步高可靠性场景。<br>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p>
</blockquote>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>RabitMQ是使用Erlang开发的，它的运行依赖Erlang。所以在使用前需要下载安装Erlang<br>Erlang 下载地址：<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">Erlang官方下载</a><br>RabbitMQ 下载地址：<a href="http://www.rabbitmq.com/install-windows-manual.html" target="_blank" rel="noopener">RabbitMQ 官方下载</a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Erlang-安装"><a href="#Erlang-安装" class="headerlink" title="Erlang 安装"></a>Erlang 安装</h2><p>Window中 Erlang下载下来的安装程序是 otp_win64_20.3.exe ，直接双击安装即可。<br><strong>配置环境变量</strong><br>添加一个系统变量 ERLANG_HOME 并设置为 Erlang 的目录 ，比如我的安装目录为 ：D:\Program Files\erl9.3<br>在 Path 系统变量中加上 %ERLANG_HOME%\bin<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nbg9j8j30tk0fd0u9.jpg" alt="Erlang配置环境变量"><br><strong>验证</strong><br>在cmd命令下输入:erl<br>能够返回版本号则表示安装与配置环境变量成功<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nbcd4nj30ak04gq2w.jpg" alt="这里写图片描述"></p>
<h2 id="RabbitMQ-安装"><a href="#RabbitMQ-安装" class="headerlink" title="RabbitMQ 安装"></a>RabbitMQ 安装</h2><p>将下载下来的 rabbitmq-server-windows-3.7.4.zip 解压到指定的安装目录即可。<br><strong>配置环境变量</strong><br>添加 RABBITMQ_SERVER 并设置为RabbitMQ 解压到的目录，如我放置的目录为 ：D:\rabbitmq_server-3.7.4<br>在 Path 系统变量末尾添加 %RABBITMQ_SERVER%\sbin </p>
<p><strong>验证</strong><br>打开cmd窗口，输入: rabbitmq-service</p>
<pre><code>PS C:\WINDOWS\system32&gt; rabbitmq-service

*********************
Service control usage
*********************

rabbitmq-service help    - Display this help
rabbitmq-service install - Install the RabbitMQ service
rabbitmq-service remove  - Remove the RabbitMQ service

The following actions can also be accomplished by using
Windows Services Management Console (services.msc):

rabbitmq-service start   - Start the RabbitMQ service
rabbitmq-service stop    - Stop the RabbitMQ service
rabbitmq-service disable - Disable the RabbitMQ service
rabbitmq-service enable  - Enable the RabbitMQ service
</code></pre><p>如有输出 以上 rabbitmq 命令的解释信息即表示安装成功。</p>
<p><strong>安装服务</strong><br>可以把RabbitMQ服务器作为服务运行，打开一个cmd窗口(管理员)，输入命令： rabbitmq-service install</p>
<pre><code>PS C:\WINDOWS\system32&gt; rabbitmq-service install
D:\Program Files\erl9.3\erts-9.3\bin\erlsrv: Service RabbitMQ added to system.
</code></pre><p>运行命令成功后我们可以查看一下服务是否已添加成功<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nbmabnj30ih07raap.jpg" alt="服务添加成功"></p>
<p><strong>启动RabbitMQ</strong><br>在cmd 窗口中输入命令:rabbitmq-service start</p>
<pre><code>PS C:\WINDOWS\system32&gt; rabbitmq-service start
RabbitMQ 服务正在启动 .
RabbitMQ 服务已经启动成功。
</code></pre><p><strong>安装web管理插件</strong><br>RabbitMQ 可以通用一个Web界面来进行管理。在cmd命令窗口中输入命令:rabbitmq-plugins enable rabbitmq_management</p>
<pre><code>PS C:\WINDOWS\system32&gt; rabbitmq-plugins enable rabbitmq_management
Enabling plugins on node rabbit@hwacer-hp:
rabbitmq_management
The following plugins have been configured:
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch
Applying plugin configuration to rabbit@hwacer-hp...
The following plugins have been enabled:
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch

set 3 plugins.
Offline change; changes will take effect at broker restart.
</code></pre><p>安装好后需要重启RabbitMQ，使用 stop 停止 再使用start 启动即可。<br>​<br>​    PS C:\WINDOWS\system32&gt; rabbitmq-service stop<br>​    RabbitMQ 服务正在停止………<br>​    RabbitMQ 服务已成功停止。<br>​<br>    PS C:\WINDOWS\system32&gt; rabbitmq-service start<br>    RabbitMQ 服务正在启动 .<br>    RabbitMQ 服务已经启动成功。</p>
<p>重启之后我们访问 <a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a>  登陆RabbitMQ 的web管理后台。默认用户密码为 guest/guest<br>重启之后可能需要过一会访问才能打开<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nbqbnej30zv061weo.jpg" alt="这里写图片描述"></p>
<p>至此，RabbitMQ 的一系列安装准备工作已经完成了，接下来要学习如何通过编码发送消息。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/7cb7ab7d/">四 ActiveMQ消息持久化与配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MQ/">MQ</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActiveMQ/">ActiveMQ</a></span><div class="content"><h1 id="一、ActiveMQ-消息持久化"><a href="#一、ActiveMQ-消息持久化" class="headerlink" title="一、ActiveMQ 消息持久化"></a>一、ActiveMQ 消息持久化</h1><h3 id="1、新建数据库"><a href="#1、新建数据库" class="headerlink" title="1、新建数据库"></a>1、新建数据库</h3><p>首先我们先新建一个mysql数据库，并把所有权限赋给新建用户，用户需要在建表的权限<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 创建数据库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> misc</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=UTF8;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> 创建用户和授权</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> misc.*</span><br><span class="line"><span class="keyword">TO</span> <span class="string">'misc_root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span></span><br><span class="line"><span class="keyword">BY</span> <span class="string">'misc_root_pwd'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> misc.*</span><br><span class="line"><span class="keyword">TO</span> <span class="string">'misc_root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span></span><br><span class="line"><span class="keyword">BY</span> <span class="string">'misc_root_pwd'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、配置数据源"><a href="#2、配置数据源" class="headerlink" title="2、配置数据源"></a>2、配置数据源</h3><p>在ActiveMQ目录中找到conf/activemq.xml 文件。<br>ActiveMQ默认使用的是kahadb 我们在xml中修改成使用mysql<br>在文件中找到：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">kahaDB</span> <span class="attr">directory</span>=<span class="string">"$&#123;activemq.data&#125;/kahadb"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>把它注释掉，添加mysql的配置<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">jdbcPersistenceAdapter</span> <span class="attr">dataSource</span>=<span class="string">"#MySQL-DS"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<pre><code>在&lt;/broker&gt;后面添加数据源的配置
</code></pre><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MySQL DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"MySQL-DS"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://127.0.0.1:3306/misc?useUnicode=true&amp;amp;characterEncoding=UTF-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"misc_root"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"misc_root_pwd"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的ID对应的就是我们上面配置的ID。<br>最后，我们需要把mysql的jar包复制到ActiveMQ目录中的lib目录下，<br>接着重新启动ActiveMQ，这时它会自动在数据库中生成三张表<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nsbyyaj30cx042aa3.jpg" alt="数据表"></p>
<p>我们可以用上一篇文章写的代码做测试，发布的消息会被存储在mysql数据库中，被消费后会自动删除。</p>
<h1 id="二、ActiveMQ配置"><a href="#二、ActiveMQ配置" class="headerlink" title="二、ActiveMQ配置"></a>二、ActiveMQ配置</h1><p>在第二篇文章中，我人提到ActiveMQ管理页面的登陆用户与密码默认是admin/admin。这个默认的用户与密码在正式环境中肯定是需要修改的。</p>
<h3 id="1、ActiveMQ管理页面登陆配置"><a href="#1、ActiveMQ管理页面登陆配置" class="headerlink" title="1、ActiveMQ管理页面登陆配置"></a>1、ActiveMQ管理页面登陆配置</h3><p>我们找到ActiveMQ目录中的 conf/jetty-realm.properties<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nsk4vpj30qf0c63ze.jpg" alt="jetty-realm.properties"><br>可以看到配置了两个用户，admin与user。<br>配置的格式为:<br>​<br>​    用户名:密码,用户角色</p>
<p>这里我们修改一下admin用户的密码，重新启动ActiveMQ，打开管理员后台<a href="http://localhost:8161/admin" target="_blank" rel="noopener">http://localhost:8161/admin</a><br>弹出的登陆框中需要输入我们新设置的用户与密码才能登陆了。</p>
<h3 id="2、ActiveMQ连接开启密码认证"><a href="#2、ActiveMQ连接开启密码认证" class="headerlink" title="2、ActiveMQ连接开启密码认证"></a>2、ActiveMQ连接开启密码认证</h3><p><strong>第一步:</strong>找到 ActiveMQ目录中的conf/credentials.properties<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nsoazzj30nj0byt9l.jpg" alt="credentials.properties"><br>这里配置的是连接的用户与密码，我们可以把密码修改成123456。<br><strong>第二步：</strong>找到activemq/conf/activemq.xml<br>在systemUsage 后面添加一个插件<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">simpleAuthenticationPlugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">authenticationUser</span> <span class="attr">username</span>=<span class="string">"$&#123;activemq.username&#125;"</span> <span class="attr">password</span>=<span class="string">"$&#123;activemq.password&#125;"</span> <span class="attr">groups</span>=<span class="string">"users,admins"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">simpleAuthenticationPlugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>位置如图:<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nsrzgoj30yk0c2jsn.jpg" alt="这里写图片描述"></p>
<p>最后重启ActiveMQ ，如果我们还用前面的代码去连接ActiveMQ 会提示用户或密码无效。我们需要修改代码中的连接工厂内容。<br>在实例化工厂时传入我们修改后的用户与密码</p>
<pre><code>//实例化连接工厂
        connectionFactory = new ActiveMQConnectionFactory(&quot;system&quot;,&quot;123456&quot;,JMSProducer.URL);
</code></pre><p>重新启动程序即可连接成功。<br>这样我们就实现了密码认证连接ActiveMQ。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/42a9c4a1/">三 JMS发布 订阅模型--ActiveMQ简单应用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MQ/">MQ</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActiveMQ/">ActiveMQ</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JMS/">JMS</a></span><div class="content"><p>[TOC]</p>
<blockquote>
<p>上一篇文章 《<a href="https://blog.csdn.net/ftdd_hw/article/details/79921004" target="_blank" rel="noopener">二、JMS 点对点模型 – ActiveMQ简单实现</a>》 我们实现了JMS点对点模型的实例，本章对第二种 发布/订阅 模型来做一个简单的实例。</p>
</blockquote>
<p>其实发布/订阅 模型与点对点模型的实现方式基本一致，因此这里就不写完整的过程了。</p>
<h1 id="一、开发环境"><a href="#一、开发环境" class="headerlink" title="一、开发环境"></a>一、开发环境</h1><pre><code>与上篇文章相同
</code></pre><h1 id="二、java项目"><a href="#二、java项目" class="headerlink" title="二、java项目"></a>二、java项目</h1><pre><code>与上篇文章相同
</code></pre><h1 id="三、具体实现"><a href="#三、具体实现" class="headerlink" title="三、具体实现"></a>三、具体实现</h1><h3 id="1、编写发布者"><a href="#1、编写发布者" class="headerlink" title="1、编写发布者"></a>1、编写发布者</h3><p>发布者的代码与上篇文章基本相同，不同的是 使用session 创建是的主题，而不是队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> .</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@name</span> JMS生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 消息的生产者类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/11 0011.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMSProducer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认连接用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line">    <span class="comment">//默认连接密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line">    <span class="comment">//默认连接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//会话</span></span><br><span class="line">        Session session;</span><br><span class="line">        <span class="comment">//目的地</span></span><br><span class="line">        Destination destination;</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        MessageProducer messageProducer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 编写生产者的步骤</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化连接工厂</span></span><br><span class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(JMSProducer.USERNAME,JMSProducer.PASSWORD,JMSProducer.URL);</span><br><span class="line">            <span class="comment">//使用连接工厂获取连接</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//使用连接创建获取会话</span></span><br><span class="line">            session = connection.createSession(<span class="keyword">true</span>,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//与点对点唯一不同的地方</span></span><br><span class="line">            <span class="comment">//使用会话连接一个主题作为目的地，如果这个主题不存在将会被创建</span></span><br><span class="line">            destination = session.createTopic(<span class="string">"HelloWorld.Topic"</span>);</span><br><span class="line">            <span class="comment">//使用会话创建消息发布者</span></span><br><span class="line">            messageProducer = session.createProducer(destination);</span><br><span class="line">            <span class="comment">//发布主题</span></span><br><span class="line">            sendMessage(session,messageProducer);</span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布者发布主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session  会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageProducer   发布者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Session session,MessageProducer messageProducer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用会话创建一条文本消息,当然，消息的类型有很多，如文字，字节，对象等,可以通过session.create..方法来创建出来</span></span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">"你好，世界! by Topic"</span>);</span><br><span class="line">            <span class="comment">//通过消息发布者发出主题</span></span><br><span class="line">            messageProducer.send(textMessage);</span><br><span class="line">            System.out.println(<span class="string">"已发送主题消息:"</span>+textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、编写订阅者"><a href="#2、编写订阅者" class="headerlink" title="2、编写订阅者"></a>2、编写订阅者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> .</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@name</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/11 0011.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMSConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认连接用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line">    <span class="comment">//默认连接密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line">    <span class="comment">//默认连接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//会话</span></span><br><span class="line">        Session session;</span><br><span class="line">        <span class="comment">//目的地</span></span><br><span class="line">        Destination destination;</span><br><span class="line">        <span class="comment">//消息的消费者</span></span><br><span class="line">        MessageConsumer messageConsumer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息的消费者编写</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化工厂</span></span><br><span class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(JMSConsumer.USERNAME,JMSConsumer.PASSWORD,JMSConsumer.URL);</span><br><span class="line">            <span class="comment">//使用实例工厂获取连接</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//使用连接获取会话</span></span><br><span class="line">            session = connection.createSession(<span class="keyword">false</span>,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//使用会话连接一个队列作为目的地，如果这个队列不存在将会被创建</span></span><br><span class="line"><span class="comment">//            destination  = session.createQueue("HelloWorld");</span></span><br><span class="line">			<span class="comment">//使用会话创建一个主题，如果这个主题不存在将会被创建</span></span><br><span class="line">            Topic topic = session.createTopic(<span class="string">"HelloWorld.Topic"</span>);</span><br><span class="line">            <span class="comment">//使用会话创建一个订阅者</span></span><br><span class="line">            messageConsumer = session.createConsumer(topic);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *获取消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">/*同步实现*/</span></span><br><span class="line">            <span class="comment">//设置接收者接收消息的时间,为了便于测试,这里定为50s,接收到消息之前（或超时之前）将一直阻塞</span></span><br><span class="line">            <span class="comment">/*TextMessage textMessage = (TextMessage) messageConsumer.receive(50000);</span></span><br><span class="line"><span class="comment">            if (textMessage!=null)&#123;</span></span><br><span class="line"><span class="comment">                System.out.println("收到的消息是:" + textMessage.getText());</span></span><br><span class="line"><span class="comment">            &#125;else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println("没有收到消息");</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="comment">/*异步实现*/</span></span><br><span class="line">            messageConsumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String text = ((TextMessage)message).getText();</span><br><span class="line">                        System.out.println(<span class="string">"收到的消息 :"</span> +text );</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*需要异步，则不关闭连接*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、关于持久订阅模式"><a href="#3、关于持久订阅模式" class="headerlink" title="3、关于持久订阅模式"></a>3、关于持久订阅模式</h3><p>在第一篇文章 《<a href="https://blog.csdn.net/ftdd_hw/article/details/79920145" target="_blank" rel="noopener">一、JMS概述</a>》中我们提到:</p>
<blockquote>
<p>发布/订阅模型还支持持久订阅的概念，在消息发布时，注册了主题的消费者不需要处于活动状态; 当消费者随后变得活跃时，它将收到消息。如果没有活动使用者注册主题，则该主题不会持有它收到的消息，除非它具有持久订阅的不活动消费者。</p>
</blockquote>
<p>主要是业务场景如下:</p>
<blockquote>
<p>A系统通过MQ推送数据到B系统。通过发布订阅的消息传送模型。由于涉及到的数据比较重要：比如是关于资金、交易、股票价格的信息。要保证B系统一定收到A系统发送的消息，考虑B系统会断电重启之类异常，故设置持久订阅模式。可以保证在B订阅A主题后，因为断电，订阅者状态变为不活动的。在B系统重启后，依然可以收到消息。</p>
</blockquote>
<p>实现持久订阅模式与普通的发布订阅模式一样，主要的不同是必须设置唯一的客户端ID和订阅者ID。</p>
<pre><code>1、在连接启动前设置设置客户端ID
2、使用createDurableSubscriber 创建订阅者并指定订阅者ID
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置客户端ID</span></span><br><span class="line">connection.setClientID(<span class="string">"client1"</span>);</span><br><span class="line"><span class="comment">//使用会话创建一个订阅者，并指定订阅者ID为 sub1</span></span><br><span class="line">TopicSubscriber topicSubscriber = session.createDurableSubscriber(topic,<span class="string">"sub1"</span>);</span><br></pre></td></tr></table></figure>
<h1 id="四、运行"><a href="#四、运行" class="headerlink" title="四、运行"></a>四、运行</h1><h3 id="1、启动ActiveMQ"><a href="#1、启动ActiveMQ" class="headerlink" title="1、启动ActiveMQ"></a>1、启动ActiveMQ</h3><p>与上一篇文章相同</p>
<h3 id="2、运行程序"><a href="#2、运行程序" class="headerlink" title="2、运行程序"></a>2、运行程序</h3><p>首先我们运行一下发布者。发布成功后我们可以在ActiveMQ 的主题中看到我们创建出来的主题消息<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4ndbkulj30tn0fpjsk.jpg" alt="这里写图片描述"></p>
<p>我们再运行一下订阅者，会发现订阅者一直在待接收消息，并没有输出我们刚刚发布的主题消息。这是因为 发布/订阅 模型 的特点:发布端在发布消息时，如果没有订阅端在线，则不会保留消息，将会认为消息已经发送。</p>
<p>因此我们可以先运行订阅者的代码，启动一个订阅者。为了体现发布/订阅模式一对多的特点，我们再启动第二个订阅者。可以在ActiveMQ中看到在两个订阅者在线了。<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nd6yf0j30t002g0sp.jpg" alt="这里写图片描述"></p>
<p>我们再启动发布者，发布一个消息。在线的两个订阅者就可以接收到我们刚刚发布的消息了。<br>我们再设想一下，其中一个订阅者断电下线了，如果再有消息发布，则待它再次上线时已经接收不到第二次发布的消息了。为了解决一个问题，我们可以使用持久订阅模式。<br>按照上面 <strong>持久订阅</strong>修改代码后重新启动两个订阅者，注意的时这两个订阅者的客户端ID与订阅者ID都必须唯一。<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nd2o4aj30e104jglz.jpg" alt="这里写图片描述"><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4ndjg4rj30h504z3yx.jpg" alt="这里写图片描述"></p>
<p>启动发布者发布一个消息 ，可以看到两个订阅者分别都接收到了发布的消息。<br>这时我们关闭 订阅者 Client1 ，再发布一个消息。这时Client2接收到了。当我们启动订阅者 Client1后，它也能够收到第二次发布的消息<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4ndfdw2j30fp05ddg7.jpg" alt="这里写图片描述"></p>
<p>至此，我们实现了JMS发布/订阅模型，并使用了持久订阅模式关于持久订阅我们需要注意的是:</p>
<blockquote>
<p>很多情况下，持久化订阅非常有用，但有的时候并非如此。虽然使用持久还是非持久通常由业务决定。但是，我们还必须考虑消息消耗的存储容量。比如有一个持久订阅者长期处于不活动的状态，那么jms服务器就必须为这个订阅者存储数以千计、万计的无用信息，浪费JMS数据仓库的宝贵空间。因为，我们必须得考虑这个问题。</p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/762f8ad8/">二 JMS 点对点模型 -- ActiveMQ简单实现</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MQ/">MQ</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActiveMQ/">ActiveMQ</a></span><div class="content"><p>[TOC]</p>
<p>本文我们使用ActiveMQ实现简单的点对点的消息模型。</p>
<h1 id="一、开发环境"><a href="#一、开发环境" class="headerlink" title="一、开发环境"></a>一、开发环境</h1><p>这里我使用的是 <em>apache-activemq-5.11.1</em> 可以去<a href="http://activemq.apache.org/download-archives.html" target="_blank" rel="noopener">官网下载</a> </p>
<ul>
<li>jdk1.8</li>
<li>idea</li>
</ul>
<h1 id="二、新建java项目"><a href="#二、新建java项目" class="headerlink" title="二、新建java项目"></a>二、新建java项目</h1><p><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nv9gsrj308c07w0sq.jpg" alt="这里写图片描述"></p>
<p>其中activemq-all-5.11.1.jar在下载下来的 <em>apache-activemq-5.11.1</em> 中就有，直接复制过来导入项目即可。</p>
<h1 id="三、具体实现"><a href="#三、具体实现" class="headerlink" title="三、具体实现"></a>三、具体实现</h1><p><strong>JMSProducer</strong>：消息的生产者<br><strong>JMSConsumer</strong>：消息的消费者</p>
<p><strong>大致步骤</strong>：<br>（1）创建连接工厂<br>（2）使用连接工厂创建一个连接<br>（3）启动连接<br>（4）使用连接创建一个会话<br>（5）使用会话创建一个队列/主题<br>（6）使用会话创建一个生产者/消费者<br>（7）使用会话创建一个消息/对象/集合/文件/字节<br>（8）使用生产者/消费者 发送/获取 消息</p>
<h3 id="1、编写生产者"><a href="#1、编写生产者" class="headerlink" title="1、编写生产者"></a>1、编写生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@name</span> JMS生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 消息的生产者类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/11 0011.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMSProducer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认连接用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line">    <span class="comment">//默认连接密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line">    <span class="comment">//默认连接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//会话</span></span><br><span class="line">        Session session;</span><br><span class="line">        <span class="comment">//目的地</span></span><br><span class="line">        Destination destination;</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        MessageProducer messageProducer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 编写生产者的步骤</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化连接工厂</span></span><br><span class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(JMSConsumer.USERNAME,JMSConsumer.PASSWORD,JMSConsumer.URL);</span><br><span class="line">            <span class="comment">//使用连接工厂获取连接</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//使用连接创建获取会话</span></span><br><span class="line">            session = connection.createSession(<span class="keyword">true</span>,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//使用会话连接一个队列作为目的地，如果这个队列不存在将会被创建</span></span><br><span class="line">            destination = session.createQueue(<span class="string">"HelloWorld"</span>);</span><br><span class="line">            <span class="comment">//使用会话创建消息生产者</span></span><br><span class="line">            messageProducer = session.createProducer(destination);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            sendMessage(session,messageProducer);</span><br><span class="line">			<span class="comment">//支持事务则必须提交</span></span><br><span class="line">            session.commit();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭连接</span></span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session  会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageProducer   生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Session session,MessageProducer messageProducer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用会话创建一条文本消息,当然，消息的类型有很多，如文字，字节，对象等,可以通过session.create..方法来创建出来</span></span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">"你好，世界!"</span>);</span><br><span class="line">            <span class="comment">//通过消息生产者发出消息</span></span><br><span class="line">            messageProducer.send(textMessage);</span><br><span class="line">            System.out.println(<span class="string">"已发送消息:"</span>+textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2、编写消费者"><a href="#2、编写消费者" class="headerlink" title="2、编写消费者"></a>2、编写消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnection;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> .</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@name</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/11 0011.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMSConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认连接用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line">    <span class="comment">//默认连接密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line">    <span class="comment">//默认连接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//会话</span></span><br><span class="line">        Session session;</span><br><span class="line">        <span class="comment">//目的地</span></span><br><span class="line">        Destination destination;</span><br><span class="line">        <span class="comment">//消息的消费者</span></span><br><span class="line">        MessageConsumer messageConsumer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息的消费者编写</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化工厂</span></span><br><span class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(JMSConsumer.USERNAME,JMSConsumer.PASSWORD,JMSConsumer.URL);</span><br><span class="line">            <span class="comment">//使用实例工厂获取连接</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//启动连接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//使用连接获取会话</span></span><br><span class="line">            session = connection.createSession(<span class="keyword">false</span>,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">//使用会话连接一个队列作为目的地，如果这个队列不存在将会被创建</span></span><br><span class="line">            destination  = session.createQueue(<span class="string">"HelloWorld"</span>);</span><br><span class="line">            <span class="comment">//使用会话获取消费者</span></span><br><span class="line">            messageConsumer = session.createConsumer(destination);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *获取消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">/*同步实现*/</span></span><br><span class="line">            <span class="comment">//设置接收者接收消息的时间,为了便于测试,这里定为50s,接收到消息之前（或超时之前）将一直阻塞</span></span><br><span class="line">            <span class="comment">/*TextMessage textMessage = (TextMessage) messageConsumer.receive(50000);</span></span><br><span class="line"><span class="comment">            if (textMessage!=null)&#123;</span></span><br><span class="line"><span class="comment">                System.out.println("收到的消息是:" + textMessage.getText());</span></span><br><span class="line"><span class="comment">            &#125;else &#123;</span></span><br><span class="line"><span class="comment">                System.out.println("没有收到消息");</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="comment">/*异步实现*/</span></span><br><span class="line">            messageConsumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String text = ((TextMessage)message).getText();</span><br><span class="line">                        System.out.println(<span class="string">"收到的消息是:"</span> +text );</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、session与事务处理"><a href="#3、session与事务处理" class="headerlink" title="3、session与事务处理"></a>3、session与事务处理</h3><pre><code>session = connection.createSession(true,Session.AUTO_ACKNOWLEDGE);
</code></pre><p><strong>第一个参数</strong></p>
<p> 要使用事务处理，必须通过作为第一个参数设置为<strong>true</strong>来创建一个事务处理会话</p>
<blockquote>
<p>事务处理允许您将整个系列的传入和传出消息分组在一起，并将它们视为原子单元。消息代理跟踪事务的各个消息的状态，但在您提交事务之前不会完成它们的传送。在发生故障时，您可以回滚事务，取消其所有消息并从头开始重新启动整个系列。<br>事务处理会话总是只有一个打开的事务，包含自会话创建或前一个事务完成以来发送或接收的所有消息。提交或回滚事务会结束该事务并自动开始另一个事务。</p>
</blockquote>
<hr>
<p>当交易中的所有消息都已成功交付时，您可以调用会话的commit方法来提交交易</p>
<pre><code>session.commit();
</code></pre><p>所有会话的传入消息都会被确认，并且所有传出的消息都将被发送。交易被视为完成，并开始新的交易。</p>
<p>发送或接收操作失败时，会引发异常。虽然可以通过忽略或重试操作来处理异常，但建议您使用会话的rollback方法回退事务：</p>
<pre><code>session.rollback（）;
</code></pre><p><strong>第二个参数</strong>：</p>
<blockquote>
<p>值可为Session.AUTO_ACKNOWLEDGE，Session.CLIENT_ACKNOWLEDGE，DUPS_OK_ACKNOWLEDGE其中一个。<br>Session.AUTO_ACKNOWLEDGE为自动确认，客户端发送和接收消息不需要做额外的工作。哪怕是接收端发生异常，也会被当作正常发送成功。<br>Session.CLIENT_ACKNOWLEDGE为客户端确认。客户端接收到消息后，必须调用javax.jms.Message的acknowledge方法。jms服务器才会当作发送成功，并删除消息。<br>DUPS_OK_ACKNOWLEDGE允许副本的确认模式。一旦接收方应用程序的方法调用从处理消息处返回，会话对象就会确认消息的接收；而且允许重复确认。</p>
</blockquote>
<h3 id="4、连接工厂-ConnectionFactory"><a href="#4、连接工厂-ConnectionFactory" class="headerlink" title="4、连接工厂 ConnectionFactory"></a>4、连接工厂 ConnectionFactory</h3><pre><code>connectionFactory = new ActiveMQConnectionFactory(JMSConsumer.USERNAME,JMSConsumer.PASSWORD,JMSConsumer.URL);
</code></pre><p>activemq默认是不需要密码，生产消费者就可以连接的<br>实例化连接工厂时我们可以去掉用户名与密码，同样可以连接到ActiveMQ<br><strong>如果ActiveMQ是部署在你本地的，则默认的用户名为admin,默认密码也为admin,地址为:tcp://localhost:61616  我们可以直接从<em>ActiveMQConnection</em> 中 取得默认的用户名，密码与地址</strong></p>
<h3 id="5、关于同步与异步"><a href="#5、关于同步与异步" class="headerlink" title="5、关于同步与异步"></a>5、关于同步与异步</h3><ul>
<li><p>同步 </p>
<blockquote>
<p>订阅者或接收者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞 </p>
</blockquote>
</li>
<li><p>异步 </p>
<blockquote>
<p>订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。上面消费者的代码中使用的是这种方法</p>
</blockquote>
</li>
</ul>
<h1 id="四、运行"><a href="#四、运行" class="headerlink" title="四、运行"></a>四、运行</h1><h3 id="1、启动ActiveMQ"><a href="#1、启动ActiveMQ" class="headerlink" title="1、启动ActiveMQ"></a>1、启动ActiveMQ</h3><p><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nv6mcrj30gm06274s.jpg" alt="ActiveMQ运行"></p>
<pre><code>如果你的64bit机器，则在这个目录下打开Activemq.bat 
32bit机器可以执行 bin\win32\activemq.bat
</code></pre><p>打开后出现以下窗口后，表示启动成功，这个窗口不能关闭<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nw0s3ej30rk0exdgn.jpg" alt="ActiveMQ打开窗口"></p>
<p>打开ActiveMQ的管理界面：<a href="http://127.0.0.1:8161/admin/" target="_blank" rel="noopener">http://127.0.0.1:8161/admin/</a><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nvmomoj30o80bjwfb.jpg" alt="ActiveMQ管理页面"></p>
<p>分别点击队列与主题可以查看发送到ActiveMQ的队列消息或主题</p>
<h3 id="2、运行生产者"><a href="#2、运行生产者" class="headerlink" title="2、运行生产者"></a>2、运行生产者</h3><p>ActiveMQ 启动好后，我们就可以运行生产者向ActiveMQ发送消息了<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nv39yjj30o30600t6.jpg" alt="运行生产者"></p>
<p>运行结束后，我们查看一下ActiveMQ的队列<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nvd7v0j30ue0710ta.jpg" alt="查看队列"></p>
<p>表示ActiveMQ自动创建一个名为”HelloWorld“的队列，队列已经收到了一条消息，暂时没有消费者，我们也可以在ActiveMQ中对消息进行浏览删除等操作</p>
<h3 id="3、运行消费者"><a href="#3、运行消费者" class="headerlink" title="3、运行消费者"></a>3、运行消费者</h3><p><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nvtumsj30o1063t94.jpg" alt="这里写图片描述"><br>这里我们使用异步接收，生产者再次发送消息时同样可以接收到。<br>如果使用同步接收，在规定的时间超时后会程序停止，关闭连接。</p>
<p>看看ActiveMQ中的队列发生的变化：</p>
<p><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nvhh96j30ue079aai.jpg" alt="接收消息后"></p>
<p>可以看到待处理消息已为0，出队消息加1，有一个消费者在线。</p>
<p>官方文档参考: <a href="https://docs.oracle.com/cd/E26576_01/doc.312/e24945/toc.htm" target="_blank" rel="noopener">https://docs.oracle.com/cd/E26576_01/doc.312/e24945/toc.htm</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/b7f40b7d/">一 JMS概述</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/MQ/">MQ</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActiveMQ/">ActiveMQ</a></span><div class="content"><p>[TOC]</p>
<h1 id="一、JMS概念"><a href="#一、JMS概念" class="headerlink" title="一、JMS概念"></a>一、JMS概念</h1><blockquote>
<p>摘要：The Java Message Service (JMS) API is a messaging standard that allows application components based on the Java Platform Enterprise Edition (Java EE) to create, send, receive, and read messages. It enables distributed communication that is loosely coupled, reliable, and asynchronous.</p>
</blockquote>
<blockquote>
<p>JMS（JAVA Message Service,java消息服务）API是一个消息服务的标准或者说是规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。jms是java的消息服务，JMS客户端之间可以通过JMS服务进行异步的消息传输</p>
</blockquote>
<blockquote>
<p>消息包括：消息头，消息扩展属性和消息休，其结构看起来与SOAP非常相似，但一般情况下，SOAP主要关注远程服务调用，而消息则专注于信息的交换。</p>
</blockquote>
<blockquote>
<p>消息分为：消息生产者，消息服务器和消息消费者。生产者与消费者之间是透明的，生产者在产生消息后，把消息发送到消息服务器，再由消息服务器发给消费者，因此它们构成了JMS的3点结构;<br>消息服务器再给消费者时，有2种模式:点到点(point to point )模式和发布/订阅(pbulish/subscribe) 模式,两种模式下面会详细介绍;</p>
</blockquote>
<h1 id="二、消息服务器"><a href="#二、消息服务器" class="headerlink" title="二、消息服务器"></a>二、消息服务器</h1><blockquote>
<p>消息服务器有很多:ActiveMQ,Jboss MQ,Open MQ,RabbitMQ ,ZeroMQ等等。<br>本文介绍的是开源的java实现的Apache ActiveMQ,后面我们会写到如何应用它与jms结合。</p>
</blockquote>
<p>看到一个对消息服务器作用的解释：</p>
<blockquote>
<p>消息队列的主要作用不是通讯，主要是用于解除子系统间的耦合，所以异构系统间的通讯实际并不是ActiveMQ发挥作用的场景，那反而是RPC发挥作用的时候。<br>消息队列更适合于需要更大流量和并发的大型系统场景，可以将消息队列视为一个可靠的通道，主交易过程在处理时，遇到需时较多同时又已经确定了条件的处理就丢到消息队列里进行后续处理，这样可以将主交易过程划分为一个一个可以异步处理的更小的处理过程，减少了主交易流程的处理时间，可以提供更快的响应速度和并发速度。例如，象淘宝这样的处理逻辑非常多的系统，在处理付款时，就可以将通知买家和卖家、记日志甚至记帐流程都放到消息队列里处理，整个主流程能够快速处理完成，继续处理下一个买家的请求。</p>
</blockquote>
<p>应用场景:<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4mafi9lj30k00dnt9n.jpg" alt="应用场景"></p>
<h1 id="三、消息模型"><a href="#三、消息模型" class="headerlink" title="三、消息模型"></a>三、消息模型</h1><h2 id="1、Point-to-Point-P2P-–-点对点模式"><a href="#1、Point-to-Point-P2P-–-点对点模式" class="headerlink" title="1、Point-to-Point(P2P) – 点对点模式"></a>1、Point-to-Point(P2P) – 点对点模式</h2><p><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4ma1cryj30dj0450tc.jpg" alt="这里写图片描述"></p>
<blockquote>
<p>每条消息都从消息生产者传递到单个消息使用者。生产者将消息传递给队列，稍后将其传递给为队列注册的其中一个消费者。任何数量的生产者和消费者都可以与同一个队列进行交互，但是每个消息都被保证传递给（并且被成功消费）一个消费者，而不会再消费。如果没有消费者注册队列，它将保存它收到的消息，并最终在消费者注册时传递消息。</p>
</blockquote>
<h2 id="2、Publish-Subscribe-Pub-Sub-–-发布订阅模型"><a href="#2、Publish-Subscribe-Pub-Sub-–-发布订阅模型" class="headerlink" title="2、Publish/Subscribe(Pub/Sub)  – 发布订阅模型"></a>2、Publish/Subscribe(Pub/Sub)  – 发布订阅模型</h2><p><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4macqaej30c606ldgm.jpg" alt="这里写图片描述"></p>
<blockquote>
<p>单个消息可以从生产者被传递到任何数量的消费者。生产者将消息发布到一个主题，然后将其发送给订阅了该主题的所有活动消费者。任何数量的生产者都可以将消息发布到给定主题，并且每条消息都可以传递给任意数量的订阅消费者。该模型还支持持久订阅的概念，在消息发布时，注册了主题的消费者不需要处于活动状态; 当消费者随后变得活跃时，它将收到消息。如果没有活动使用者注册主题，则该主题不会持有它收到的消息，除非它具有持久订阅的不活动消费者。</p>
</blockquote>
<h1 id="三、消息的消费"><a href="#三、消息的消费" class="headerlink" title="三、消息的消费"></a>三、消息的消费</h1><p>在JMS中，消息的产生和消息是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。<br>○ 同步 </p>
<blockquote>
<p>订阅者或接收者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞 </p>
</blockquote>
<p>○ 异步 </p>
<blockquote>
<p>订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</p>
</blockquote>
<h1 id="四、JMS编程模型"><a href="#四、JMS编程模型" class="headerlink" title="四、JMS编程模型"></a>四、JMS编程模型</h1><p>1、 ConnectionFactory</p>
<blockquote>
<p>创建Connection对象的工厂，针对两种不同的jms消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。</p>
</blockquote>
<p>2、Destination</p>
<blockquote>
<p>Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。</p>
</blockquote>
<blockquote>
<p>所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。</p>
</blockquote>
<p>3、Connection</p>
<blockquote>
<p>Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。</p>
</blockquote>
<p>4、Session</p>
<blockquote>
<p>Session是我们操作消息的接口。可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。</p>
</blockquote>
<p>5、消息的生产者</p>
<blockquote>
<p>消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。</p>
</blockquote>
<p>6、消息消费者</p>
<blockquote>
<p>消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。</p>
</blockquote>
<p>7、MessageListener</p>
<blockquote>
<p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener。</p>
</blockquote>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By HJW</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>