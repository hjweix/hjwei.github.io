<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="HJW"><meta name="copyright" content="HJW"><title>HJW</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3a101c3aa7d1cde834d9d6b197500902";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-139524382-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/17232182?s=460&amp;v=4"></div><div class="author-info__name text-center">HJW</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/hjwjw">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">88</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">62</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">22</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HJW</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">HJW</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/posts/525fe2aa/">Spring Cloud Config 同步刷新配置及加密解密</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/微服务/">微服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/刷新配置/">刷新配置</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/配置加密解密/">配置加密解密</a></span><div class="content"><p>目录</p>
<p>[TOC]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的文章为微服务架构引入了统一配置管理Spring cloud config，实现了各个微服务配置分布式管理。配置被修改后，我们不可能重新启动微服务，前面说到过Spring Cloud Config可以自动更新配置，本篇会对同步自动刷新配置进行学习记录。另外配置文件存储在GIT仓库中，很多场景下，对于某些敏感的配置内容(例如数据库账号，密码等)，应当加密存储。部分内容涉及上篇文章：<a href="https://blog.csdn.net/FTDD_HW/article/details/82053079" target="_blank" rel="noopener">微服务学习笔记–使用Spring Cloud Config 统一管理微服务配置</a></p>
<h1 id="同步刷新"><a href="#同步刷新" class="headerlink" title="同步刷新"></a>同步刷新</h1><p>在项目中加入actuator，就会有一个<code>/refresh</code>端点，当配置被修改后，只需要手动通过POST方式去访问这个端口，项目配置即可被刷新。但这种手动刷新的方式只能针对单个项目刷新，如果所有的微服务节点的配置都需要手动去刷新则工作量会很大。因此这里介绍的是同步刷新的方式，使用Spring Cloud Bus实现。之所以它能实现同步刷新，是因为Spring Cloud Bus 使用了轻量级的消息代理(如rabbitmq,kafka)，通过广播的方式让所以有被修改配置的微服务节点都能被刷新。</p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>在上篇文章的Config Server，用户微服务，电影微服务三个项目中都引入以下依赖：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加RabbitMQ"><a href="#添加RabbitMQ" class="headerlink" title="添加RabbitMQ"></a>添加RabbitMQ</h2><p>1、RabbitMQ安装可以参考之前的文章：<a href="https://blog.csdn.net/FTDD_HW/article/details/80082790" target="_blank" rel="noopener">RabbitMQ学习系列:一、RabbitMQ 的安装</a><br>在三个项目的配置文件中添加rabbitmq配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq:</span><br><span class="line">  host: localhost</span><br><span class="line">  port: 5672</span><br><span class="line">  username: guest</span><br><span class="line">  password: guest</span><br></pre></td></tr></table></figure></p>
<h2 id="添加测试方法"><a href="#添加测试方法" class="headerlink" title="添加测试方法"></a>添加测试方法</h2><p>其实这样就改造完成了，为了方便测试，我们把git上存储的各个配置文件添加相应配置：</p>
<pre><code>profile: user-dev-v1.0
</code></pre><p>在用户与电影微服务中的Controller中添加以下红框中的内容以获取上面添加的配置值：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nlgro1j30cn0bmt9i.jpg" alt="添加内容"></p>
<blockquote>
<p><code>@RefreshScope</code> 添加该注解的类会在类更改时得到特殊处理</p>
</blockquote>
<p>通过这样改造，我们可以修改上面的属性，push到仓库，刷新后测试属性是否被更新来验证我们配置的Spring cloud bus 是否生效。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>首先我们访问用户与电影微服务的<code>getProfile</code>方法查看当前配置的<code>profile</code>值：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nlwksxj30ax0230so.jpg" alt="用户微服务profile"><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nm7ua2j309r02d748.jpg" alt="电影微服务Profile"><br>把<code>microservice-provider-user-dev.yml</code>与 <code>microservice-consumer-movie-dev.yml</code>中的profile配置值分别修改成：user-dev-v2.0    和 movie-dev-v2.0  并推送到git仓库。再次使用getProfile方法获取配置值发现没有变化。<br>通过POSTMAN访问Config Server的<code>/bus/refresh</code>  端口：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nm3100j30q605wdfy.jpg" alt="POSTMAN"><br>再次访问用户与电影微服务的<code>getProfile</code>方法：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nkf9m1j309b024748.jpg" alt="这里写图片描述"><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nkkpddj309702h748.jpg" alt="这里写图片描述"><br>发现获取的配置值已经改变，说明我们刷新配置生效了。<br>这里我们是访问Config Server的 <code>/bus/refresh</code>端口，其实访问用户或电影微服务的<code>/bus/refresh</code>端口效果也是一样的，不过在实际环境中，微服务被迁移，网络地址可能会发生改变，因此把Config Server也加入到消息总线中，它的地址一般比较固定，它的配置更新状态可以广播到其它微服务节点中。</p>
<h2 id="设置自动刷新"><a href="#设置自动刷新" class="headerlink" title="设置自动刷新"></a>设置自动刷新</h2><p>前面其实还是使用手动通过POST方式去访问<code>/bus/refresh</code>端口进行刷新，但已经实现了同步刷新。关于自动刷新我们可以借助GIT仓库的WebHook配置，在PUSH时让GIT给指定网络地址发送一个POST请求。<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nktj7jj30ru06taak.jpg" alt="WebHooks"><br>由于这里是在本地进行学习测试，没有网络地址可以进行测试。</p>
<h1 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h1><p>Config Server 为配置内容的加密解密提供了两种方式。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><h3 id="安装JCE"><a href="#安装JCE" class="headerlink" title="安装JCE"></a>安装JCE</h3><p>使用JCE,下载地址：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html</a><br>需要对应相应版本的JDK，上面地址是jdk8的。<br>下载后打开解压有两个jar文件，把它们替换JDK安装目录下：<br>%JAVA_HOME%\jre\lib\security<br> 在Config Server的配置文件中添加密钥：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">encrypt:</span><br><span class="line">  key: wei</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>key 可以自己随意设置<br>需要<code>注意</code>的是，这个配置必须配置在bootstrap.yml中，因此在Config Server中我们需要新建bootstrap.yml并将配置写入。</p>
</blockquote>
<h3 id="存储加密内容"><a href="#存储加密内容" class="headerlink" title="存储加密内容"></a>存储加密内容</h3><p>做好上面的工作后，重新启动Config Server 项目，可能在控制到看到打印了以下端点：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nmahfjj30dg03rdg7.jpg" alt="加密解密端口"><br>这两个端点可以进行加密与解密。我们用POSTMAN把上面添加的<code>profile</code>配置值加密：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nlz7syj30qg0ba74o.jpg" alt="加密"><br>然后把返回的加密值写入配置文件中，以<code>{cipher}</code>开关，以让Config Server识别这是需要解密的内容。<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nl5bsgj30kp0373yl.jpg" alt="添加加密内容"><br>将修改后的配置文件push到git仓库，使用<code>/bus/refresh</code>刷新配置后访问用户微服务的<code>getProfile</code>方法以测试：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nl7ojvj309a02fdfs.jpg" alt="测试"><br>可以看到返回到Config Client的配置已经被自动解密了</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密相对与对称加密来说更安全。<br><strong>1、生成keyStore</strong><br>非对称加密可以使用JDK自带的keytool工具，打开cmd输入以下命令：</p>
<pre><code>keytool -genkeypair -alias config-server -keyalg RSA -keystore config-server.keystore
</code></pre><p>按下图方式填写内容：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nlm1k9j30r50ap3yx.jpg" alt="生成keystore"><br>方便测试，上图我只输入了红框中的内容，其它地方直接回车即可。</p>
<p>运行完后会在当前运行路径下生成一个<code>config-server.keystore</code> 把这个文件移动到Config Server项目的 <code>\src\main\resources</code>目录下。<br><strong>2、添加配置</strong><br>在Config Server 的bootstrap.yml配置下添加以下内容：<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line"><span class="attr">  key-store:</span></span><br><span class="line"><span class="attr">    location:</span> <span class="string">config-server.keystore</span></span><br><span class="line"><span class="attr">    alias:</span> <span class="string">config-server</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">******</span></span><br><span class="line"><span class="attr">    secret:</span> <span class="string">******</span></span><br></pre></td></tr></table></figure></p>
<p>这里的<code>password</code>与<code>secret</code>分别是生成keystroe时第一次与第二次输入的密码。<code>location</code> 是指向config-server.keystore的放置路径。<br><strong>3、非对称加密测试</strong><br>配置好上面的内容后，重启Config Server ，和对称加密一样，通过POSTMAN生成加密内容，写到配置文件中PUSH到GIT仓库即可。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/e60cfe17/">Spring Cloud Config 统一管理微服务配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/微服务/">微服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spring-Cloud-Config/">Spring Cloud Config</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/微服务配置管理/">微服务配置管理</a></span><div class="content"><p>目录</p>
<p>[TOC]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微服务架构中为了方便管理与更新各微服务的配置，在Spring Cloud中可以使用 Spring Cloud Config 来统一管理系统内各微服务的配置文件。使用Config统一管理后，可实现git分布式版本控制，不同环境不同配置，动态调整自动更新配置等功能。<br>Spring Cloud Config 包括Config Server 和 Config Client 两部分，Config Server用于管理配置，Config Client 则与各微服务集成负责向Config Server请求获取配置并进行缓存以提高性能。<br>Config Server默认使用Git存储配置内容，当然也可以使用SVN,本地文件系统或Vault存储配置。<br>下面把Config Server 、 Config Client 和 Eureka配合使用记录下来。</p>
<h1 id="编写Config-Server"><a href="#编写Config-Server" class="headerlink" title="编写Config Server"></a>编写Config Server</h1><p>在编写Config Server 前，我们需要使用Git作为后端存储。</p>
<h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><p>可以在github.com上创建一个仓库。先前面用到了电影与用户微服务的配置文件直接放到仓库中。配置文件命名使用规范：<code>服务名+环境</code> 。这里我创建的仓库如下图：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nr6cczj30rk062mxm.jpg" alt="git仓库"><br>每个微服务的配置我这里按开发与生产环境分别部署两份。配置文件内容与前面做的demo配置一样，但开发与生产配置的端口号不同。<br>另外，方便测试版本控制，我给仓库新建了一个 config-label-v2.0 分支，将端口号进行修改以便区分。</p>
<h2 id="编写Config-Server-1"><a href="#编写Config-Server-1" class="headerlink" title="编写Config Server"></a>编写Config Server</h2><p>新建一个Spring Boot项目，<br><strong>1、引入依赖</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;Edgware.RELEASE&lt;/version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">		&lt;/dependencies&gt;</span><br><span class="line">	&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>2、添加注解</strong><br>在启动类上添加 <code>@EnableConfigServer</code> 声明这是一个Config Server<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(MicroserviceConfigServerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>因为我们是配合Eureka使用，因此启动类上也需要添加 <code>@EnableDiscoveryClient</code> 注解 </p>
</blockquote>
<p><strong>3、编写配置</strong><br>编写application.yml ，并添加以下配置：<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span>  <span class="string">microservice-config-server</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/hjwzyy/spring-cloud-edgware-configServer-demo</span></span><br><span class="line"><span class="attr">          username:</span> <span class="string">******@*******.com</span></span><br><span class="line"><span class="attr">          password:</span> <span class="string">*******</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://user:admin@localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure></p>
<p>至此 一个简单的Config Server就完成了。<br>下面我们来启动Config Server进行测试。<br>访问如下地址：<a href="http://localhost:8082/microservice-provider-user/dev" target="_blank" rel="noopener">http://localhost:8082/microservice-provider-user/dev</a> 如下图：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nruv9uj30ma0ivt9a.jpg" alt="查看配置"><br>这里显示的是我们放在Git仓库里的用户微服务的开发环境配置文件，说明Config Server正常。<br>测试版本控制，访问如下地址：<a href="http://localhost:8082/microservice-provider-user/dev/config-label-v2.0" target="_blank" rel="noopener">http://localhost:8082/microservice-provider-user/dev/config-label-v2.0</a><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nrpufjj30l908rdg1.jpg" alt="分支配置"><br>可以看到访问地址加上指定分支后显示的是指定分支下的配置文件。<br>​<br>​    关于Config Server 获取git上的资源信息遵循如下规则：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure></p>
<p>我们可以按以上规则去访问git上的配置文件</p>
<h1 id="编写Config-Client"><a href="#编写Config-Client" class="headerlink" title="编写Config Client"></a>编写Config Client</h1><p>前面我们写过，Config Client与微服务集成，因此在微服务中添加Config的依赖，稍微配置一下就可以了。<br>下面我将前面的用户微服务与电影微服务添加Config Client，整个用户与电影微服务的编写，服务注册这里不再贅述，可参考前文：</p>
<p><a href="https://blog.csdn.net/FTDD_HW/article/details/80874370" target="_blank" rel="noopener">微服务简单实例–电影购票</a></p>
<p><a href="https://blog.csdn.net/FTDD_HW/article/details/80922134" target="_blank" rel="noopener">微服务学习笔记 –使用Spring Cloud Eureka实现服务注册与发现</a></p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>向用户微服务添加以下依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>电影微服务同上添加依赖。</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>因为用户微服务的配置已经放在了git上，所以项目的中的application.yml文件只需要配置一个端口即可，其它配置清除：<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8005</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>git上的配置文件也可以配置端口，并且会以git上的配置文件为准</p>
</blockquote>
<p><strong>添加<code>bootstrap.yml</code>配置文件</strong> </p>
<blockquote>
<p>Spring Cloud 有一个“引导上下文”的概念，这里主应用程序的父上下文。引导上下文负责从配置服务器加载配置属性，以及解密外部配置文件中的属性。和主应用程序加载application.*(yml或priperties)中的属性不同，引导上下文加载bootstarap.*中的属性。配置在bootstrap.*中的属性有更高的优先级，因此默认情况下它们不能被本地配置覆盖。<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">microservice-provider-user</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        serviceId:</span> <span class="string">microservice-config-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://user:admin@localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>配置文件中加上服务注册配置，因为我们是与Eureka配合使用，Config Client需要先从Eureka中找到Config Server，再从Config Server中获取到对应的配置。而获取对应配置是依靠<code>spring.application.name</code> 与 <code>spring.cloud.config.profile</code>来找到对应配置文件的。还记得前面我们在Git仓库中建立的配置文件命名吗？都是以  <code>服务名+环境</code> 进行命名的。</p>
</blockquote>
<p> <code>spring.cloud.config.label</code> 则是指定分支为主分支 <code>master</code><br><code>spring.cloud.config.discovery.enabled</code> 表示使用服务发现组件中的Config Server，而不是自己指定的Config Serverr uri，默认为false<br><code>spring.cloud.config.discovery.serviceId</code>指定Config Server在服务发现中的serviceId，默认是configserver ，因此这里写的是前面编写的Config Server 的<code>spring.application.name</code></p>
<p><strong>电影微服务的配置同上</strong><br>至此，Config Client已经配置完成。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>分别启动Eureka，Config Server，用户微服务与电影微服务。<br>在Eureka界面可以看到有三个注册的服务：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nrzt57j30wh06n0tv.jpg" alt="注册服务"><br>用户微服务与电影微服务启动的端口是git配置文件中设置的端口，访问各各微服务通过正常获取数据：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nrml33j30bm04pq2w.jpg" alt="正常获取数据"><br>说明配置文件已经实现了通过Spring cloud Config 统一管理与获取。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/31090589/">Hystrix实现微服务的容错处理与监控数据</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/微服务/">微服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Hystrix/">Hystrix</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Turbine/">Turbine</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/微服务容错/">微服务容错</a></span><div class="content"><p>目录</p>
<p>[TOC]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在微服务架构中，如果服务提供者响应缓慢，那么服务消费者的请求就会被强制等待，或响应超时。在高负载场景下，如果不做任何处理，这类问题可能会导致服务消费者资源耗竭甚至整个系统的崩溃。</p>
<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><p>Hystrix是一个实现了超时机制和断路器模式的工具类库。是由Netflix开源的，用于隔离访问系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。<br>Hystrix主要通过以下几点实现延迟和容错：<br><strong>1、包裹请求：</strong> 使用HystrixCommand（或HystrixObservableCommand）包裹对依赖的调用逻辑，每个命令在独立线程中执行。这使用到了设计模式中的“命令模式”。<br><strong>2、跳闸机制：</strong> 当某服务的错误率超过一定阈值时，Hystrix可以自动或手动跳闸，停止请求该服务一段时间 。<br><strong>3、资源跳闸：</strong> Hystrix为每个依赖都维护了一个小型的线程池（或者信号量）。如果该线程池已满，发往该依赖的请求就被立即拒绝，而不是排除等候，从而加速失败判定。<br><strong>4、监控：</strong> Hystrix可以近乎实时地监控运行指标和配置的变化，例如成功、失败、超时、以及被拒绝的请求等。<br><strong>5、回退机制：</strong> 当请求失败、超时、被拒绝，或当断路器打开，执行回退逻辑。回退逻辑可由开发人员自行提供，例如返回一个缺省值。<br><strong>6、自我修复：</strong> 断路器打开一段时间后，会自动进行“半开”状态。断路器打开、关闭、半开的逻辑转换。</p>
<h1 id="整合Hystrix"><a href="#整合Hystrix" class="headerlink" title="整合Hystrix"></a>整合Hystrix</h1><p>在Spring Cloud 中整合Hystrix非常方便。我们以前面的服务消费者项目为例进行修改。</p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="修改启动类"><a href="#修改启动类" class="headerlink" title="修改启动类"></a>修改启动类</h2><p>在启动类中添加注解 <code>@EnableHystrix</code> 或<code>@EnableCircuitBreaker</code>，为项目启用断路器支持。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceConsumerMovieRibbonApplication</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(MicroserviceConsumerMovieRibbonApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(UserController.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"findByIdFallback"</span>)</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://microservice-provider-user/"</span> + id,User.class);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findByIdFallback</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(-<span class="number">1L</span>);</span><br><span class="line">        user.setName(<span class="string">"默认用户"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/log-user-instance"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logUserinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServiceInstance serviceInstance = <span class="keyword">this</span>.loadBalancerClient.choose(<span class="string">"microservice-provider-user"</span>);</span><br><span class="line">        UserController.LOGGER.info(<span class="string">"&#123;&#125;:&#123;&#125;:&#123;&#125;"</span>,serviceInstance.getServiceId(),serviceInstance.getHost(),serviceInstance.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Controller中，我们为<code>findById</code>方法编写了一个回退方法<code>findByIdFallback</code>，在<code>findByIdFallback</code>方法中返回了一个默认用户，在<code>findById</code>中添加注解<code>@HystrixCommand</code>在<code>fallbackMethod</code>属性中指定它的回退方法即可。</p>
<h2 id="容错测试"><a href="#容错测试" class="headerlink" title="容错测试"></a>容错测试</h2><p>修改好上述内容后我们分别启动一个服务提供者，服务消费者与Eureka。访问服务消费者：<a href="http://localhost:8011/user/1" target="_blank" rel="noopener">http://localhost:8011/user/1</a> 可以正常得到数据。当我们把服务提供者关闭后再次访问，会发现返回了之前的默认用户:<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nf4knej30aq04xt8o.jpg" alt="默认用户">。</p>
<h1 id="Hystrix监控"><a href="#Hystrix监控" class="headerlink" title="Hystrix监控"></a>Hystrix监控</h1><p>前面提到Hystrix除了可以实现容错处理，还有监控功能。<br>使用Hystrix的模块<code>hystrix-metrics-event-stream</code>，就可以将这些监控信息以文本的形式暴露给外部系统。<code>spring-cloud-starter-netflix-hystrix</code>已经包含了这个模块，我人只需要添加Actuator，就可以使用<code>/hystrix.stream</code>端口获得Hystrix监控信息。</p>
<h2 id="添加Actuator"><a href="#添加Actuator" class="headerlink" title="添加Actuator"></a>添加Actuator</h2><p>只需要在项目中添加Actuator依赖即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>重新启动项目，访问 <a href="http://localhost:8011/hystrix.stream会出现类似如下图的信息：" target="_blank" rel="noopener">http://localhost:8011/hystrix.stream会出现类似如下图的信息：</a><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4ndypzrj317z08s3z6.jpg" alt="监牢信息"></p>
<h2 id="可视化监控数据"><a href="#可视化监控数据" class="headerlink" title="可视化监控数据"></a>可视化监控数据</h2><p>上一节我们可以看到监控信息，但都是通过文字形式展示的，不能直观的显示系统状态。<br>我们可以使用Hystrix Dashboard，让监控数据图形化，可视化。<br>我们新建一个最简单的Spring Boot 项目</p>
<ul>
<li><p>添加以下依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动类添加注解<br>在启动类上添加注解 <code>@EnableHystrixDashboard</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceHystrixDashboardApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(MicroserviceHystrixDashboardApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件<br>在配置文件中添加访问端口</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8030</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动项目<br>启动新建的项目：<a href="http://localhost:8030/hystrix" target="_blank" rel="noopener">http://localhost:8030/hystrix</a> ，就可以看到Dashboard界面，在中间的地址栏中输入上一节中我们查看监控数据的地址<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4ne9e5vj310n0gxq5w.jpg" alt="Dashboard"><br>随意填写一个Title 点击按钮，Dashboard即可把<a href="http://localhost:8011/hystrix.stream" target="_blank" rel="noopener">http://localhost:8011/hystrix.stream</a> 的文本信息转化成可视化视图：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4ney8rlj31890c4myo.jpg" alt="可视化监控"><br>关于显示的指标信息解释可以参考如下图：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nect0fj30hs09nt9i.jpg" alt="指标解释"></p>
<h1 id="Turbine聚合监控数据"><a href="#Turbine聚合监控数据" class="headerlink" title="Turbine聚合监控数据"></a>Turbine聚合监控数据</h1><p>上一节我们把要监控的项目的 /hystrix.stream 地址填入Dashboard即可以可视化的监控项目状态。但在微服务中往往有若干个微服务，每个微服务又有多个实例，如果这样一个个监控非常不方便。这一节我们使用Turbine来聚合Hystrix监控数据。<br>首页我们把服务消费者项目复制一份，<code>修改应用名、端口与方法名</code>，模拟多个微服务的场景。<br>这里我把前面使用的服务消费者项目直接复制一份，在配置文件中修改<code>spring.application.name</code>为microservice-consumer-movie2,修改<code>server.port</code>为8031。在<code>Controller</code>中将原方法<code>findById</code> 名更改为<code>findById2</code>,回退方法名更改为<code>findByIdFallback2</code><br>然后新建一个Spring Boot项目<br><strong>1、依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2、配置文件</strong><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8031</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">microservice-hystrix-turbine</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">        defaultZone:</span> <span class="attr">http://user:admin@localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">turbine:</span></span><br><span class="line"><span class="attr">  app-config:</span> <span class="string">microservice-consumer-movie,microservice-consumer-movie2</span></span><br><span class="line"><span class="attr">  cluster-name-expression:</span> <span class="string">"'default'"</span></span><br></pre></td></tr></table></figure></p>
<p>在配置文件中，把项目注册到Eureka，使用 <code>turbine.app-config</code> 属性添加需要聚合监控的项目名<br><strong>3、添加注解</strong><br>在启动类上添加注解 <code>@EnableTurbine</code></p>
<p><strong>4、聚合监控数据</strong><br>最后我们启动服务提供者，两个服务消费者，一个Eureka，上一节新建的Dashboard项目与刚新建的Turbine项目。<br>上一节中我们是把服务消费者的 <code>/hystrix.stream</code> 放入Dashboard中进行可视化，但Turbine项目已经聚合了两个服务消费者的监控数据，因为我们只需要把Turbine项目的地址放入Dashboard中即可。<br>Turbine项目聚合监控信息的地址为 <a href="http://localhost:8031/turbine.stream" target="_blank" rel="noopener">http://localhost:8031/turbine.stream</a><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nesd1kj30y80gidiq.jpg" alt="tuebine聚合"><br>点击按钮后可展示如下图的可视化界面<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4ne5es5j30os0bxdgo.jpg" alt="聚合后的可视化界面"><br>可以看到两个服务消费者的方法都显示出来了，如果同名会显示成一个。<br>这样我们就完成了监控的聚合，更加方便的显示各各微服务的状态。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/f0c3ea98/">Feign实现声明式REST调用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/微服务/">微服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Feign/">Feign</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/声明式REST-API/">声明式REST API</a></span><div class="content"><p>目录</p>
<p>[TOC]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的文章中，服务消费者调用服务提供者的接口我们是使用RestTemplate实现的REST API调用的。但这种方式在参数比较多时会变得低效，难以维护。</p>
<h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><p>Feign是Netflix开发的声明式，模板化的HTTP客户端。它可以让我们更加便捷，优雅的调用HTTP API。Feign有自己的注解，在Spring Cloud中对Feign进行了增强，使其可以支持Spring MVC注解，并整合Ribbon与Eureka。</p>
<h1 id="整合Feign"><a href="#整合Feign" class="headerlink" title="整合Feign"></a>整合Feign</h1><p>前面的服务消费都使用RestTemplate来调用服务提供者，这里更改成使用Feign，使用声明式的RestFul API。</p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置其实无需修改<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">microservice-consumer-movie</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://user:admin@localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="创建Feign接口"><a href="#创建Feign接口" class="headerlink" title="创建Feign接口"></a>创建Feign接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"microservice-provider-user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@FeignClient</code> 注解中的<code>microservice-provider-user</code> 是服务提供者的主机名，用于创建Ribbon负载均衡器，与上篇文章中使用主机名是一样的。也可以使用URL属性指定请求的URL:</p>
<pre><code>@FeignClient(name = &quot;microservice-provider-user&quot;,url=&quot;http://localhost:8000/&quot;)
</code></pre><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserFeignClient userFeignClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userFeignClient.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller 中去掉RestTemplate，定义 UserFeignClient 。我在测试中定义的 UserFeignClient 会提示 <code>Could not autowire. No beans of &#39;UserFeignClient&#39; type found.</code> 但运行并不影响。</p>
<h2 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h2><p>在启动类上注解 <code>@EnableFeignClients</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceSimpleConsumerMovieApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(MicroserviceSimpleConsumerMovieApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>完成上述修改后，就可以像之前一样去调用服务提供者了。<br>与上篇Ribbon一样，启动一个Eureka，一个或多个服务提供者(Feign自己集成了Ribbon)，启动修改完成后的服务消费者。<br>访问<a href="http://localhost:8011/user/1" target="_blank" rel="noopener">http://localhost:8011/user/1</a><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nh1pk3j30b604xjrc.jpg" alt="测试"></p>
<h1 id="自定义Feign配置"><a href="#自定义Feign配置" class="headerlink" title="自定义Feign配置"></a>自定义Feign配置</h1><p>按上一节整合Feign很简单，但有时候我们想自定义Feign的配置，如更改Feign使用的编码器，解码器，契约，拦截器等。<br>如服务提供者是需要Http Basic的认证才能调用的，那么服务消费者可以在Feign中自定义配置拦截器，添加 Http Basic 认证。</p>
<h2 id="编写配置类"><a href="#编写配置类" class="headerlink" title="编写配置类"></a>编写配置类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicAuthRequestInterceptor <span class="title">basicAuthRequestInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>,<span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个配置，只需要在Feign接口类<code>UserFeignClient</code>的<code>@FeignClient</code>注解中添加<code>configuration</code> 属性</p>
<pre><code>@FeignClient(name = &quot;microservice-provider-user&quot;,configuration=&quot;FooConfiguration.class&quot;)
</code></pre><p>另外还需要把服务提供者加上Http Basic认证。<br>在服务提供都项目中添加security<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>在其配置文件中添加用户名与密码：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">  basic:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  user:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>重新启动服务提供者与服务消费者<br>这里我们直接去访问服务提供者是需要进行认证的：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4ngoqcxj30k207xq37.jpg" alt="测试"><br>访问服务消费者，通过服务消费者去调用服务提供者，不会弹出认证窗口，因为服务消费者在Feign中已经配置了用户名与密码了。<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nglxamj30ac04vglk.jpg" alt="这里写图片描述"></p>
<h1 id="Feign服务间传送文件"><a href="#Feign服务间传送文件" class="headerlink" title="Feign服务间传送文件"></a>Feign服务间传送文件</h1><p>转 ：<a href="https://blog.csdn.net/qq_29534483/article/details/81330269" target="_blank" rel="noopener">Spring Cloud微服务【Finchley.RELEASE版本】(四)使用feign服务间传送文件</a></p>
<h1 id="Feign构造多参数请求"><a href="#Feign构造多参数请求" class="headerlink" title="Feign构造多参数请求"></a>Feign构造多参数请求</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>对于GET请求可以使用Map来构建。接口修改如下 :<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"microservice-provider-user"</span>,configuration = FooConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(@RequestParam Map&lt;String,Object&gt; map)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用时构建一个Map传递到接口中</p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>post请求则简单得多，可以直接使用 <code>User</code> 实体类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"microservice-provider-user"</span>,configuration = FooConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(@RequestBody User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/d09d9c9a/">Ribbon实现负载均衡</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/微服务/">微服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Ribbon/">Ribbon</a></span><div class="content"><p>目录</p>
<p>[TOC]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了实现微服务架构的高可用性，一般在生产环境中，各个微服务会部署多个实例。这里我们需要用到负载均衡，将服务消费者的请求分摊到多个服务提供者实例上。</p>
<h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><p>Ribbon 是Netflix发布的负载均衡器，它有助于控制HTTP和TCP客户端的行为。Ribbon配置好后，它可以根据如轮询，随机等负载均衡算法自动帮助服务消费去请求。在Spring Cloud中，Ribbon 与Eureka可以很好的配合 ，Ribbon向Eureka注册后可以自动从Eureka中获取服务提供者的地址列表，然后基于某种负载均衡算法去请求其中一个服务提供者实例。</p>
<h1 id="集成Ribbon"><a href="#集成Ribbon" class="headerlink" title="集成Ribbon"></a>集成Ribbon</h1><p>在Spring Cloud中使用Ribbon很简单，只需要做一点小修改。<br>将 <a href="https://blog.csdn.net/FTDD_HW/article/details/80874370" target="_blank" rel="noopener">微服务简单实例–电影购票</a> 中的服务消费者为基础进行修改。</p>
<p>##添加依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>由于 Eureka已经包含了Ribbon 所以这里其实不需要添加上面这个依赖了。</p>
<h2 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h2><p>还需要为RestTemplate添加@LoadBalanced注解。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceConsumerMovieRibbonApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Bean</span> 是一个方法注解，作用是实例化一个Bean并使用该方法的名称命名。在本例中，添加<span class="doctag">@Bean</span>注解的restTemplate()方法，等价于RestTemplate restTemplate = new RestTemplate();</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@LoadBalanced</span> 可以为RestTemplate整合Ribbon 使其具备负载均衡的能力。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(MicroserviceConsumerMovieRibbonApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="修改Controller"><a href="#修改Controller" class="headerlink" title="修改Controller"></a>修改Controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(UserController.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://microservice-provider-user/"</span> + id,User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/log-user-instance"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logUserinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServiceInstance serviceInstance = <span class="keyword">this</span>.loadBalancerClient.choose(<span class="string">"microservice-provider-user"</span>);</span><br><span class="line">        UserController.LOGGER.info(<span class="string">"&#123;&#125;:&#123;&#125;:&#123;&#125;"</span>,serviceInstance.getServiceId(),serviceInstance.getHost(),serviceInstance.getPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要把请求地址改成 <a href="http://microservice-provider-user/" target="_blank" rel="noopener">http://microservice-provider-user/</a> 。microservice-provider-user是用户微服务(服务提供者)的虚拟主机名。当Ribbon与Eureka配合使用时，会自动将虚拟主机名映射成微服务的网络地址。在新增的方法logUserinstance() 方法中使用LoadBalancerClient 的API更加直观的获取当前选择的用户微服务节点。<br><code>注意需要在服务提供者的配置文件中添加其虚拟主机名，并且命令不能使用 _ ：</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: microservice-provider-user</span><br></pre></td></tr></table></figure></p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>我们启动前文中 <a href="https://blog.csdn.net/FTDD_HW/article/details/80922134" target="_blank" rel="noopener">微服务学习笔记 –使用Spring Cloud Eureka实现服务注册与发现</a> 的一个Eureka项目，启动多个服务提供者，因为是在本地做测试，需要把端口改成不一样的，避免端口占用。最后启动修改后的服务消费者。查看Eureka界面：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nur922j317s055gm4.jpg" alt="微信截图_20180806151100.png"><br>可以看到在Eureka上注册了三个服务提供者，分别使用了不同的端口号。另外还注册了集成Ribbon后的服务消费者。<br>访问localhost:8010/user/1 可以请求到数据<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nuock1j30hx04k744.jpg" alt="微信截图_20180806155709.png"><br>多次请求后后台可以看到请求会随机分配给不同的服务提供者。<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nujob1j31680buwgl.jpg" alt="微信截图_20180806155835.png"><br>可以通过访问 <a href="http://localhost:8010/log-user-instance" target="_blank" rel="noopener">http://localhost:8010/log-user-instance</a> 更加直观的查看负载均衡效果。<br>多次访问 <a href="http://localhost:8010/log-user-instance" target="_blank" rel="noopener">http://localhost:8010/log-user-instance</a> ，查看后台日志如下：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nug4xbj30zf06awfc.jpg" alt="微信截图_20180806160158.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/6a085911/">Centos 7离线安装Nginx 配置负载均衡集群</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Nginx/">Nginx</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Nginx-tomcat/">Nginx+tomcat</a></span><div class="content"><p>目录</p>
<p>[TOC]</p>
<hr>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p> 项目中有三台应用服务器，系统为Centos 7 ，应用地址分别为:</p>
<ul>
<li>192.168.198.229:8080</li>
<li>192.168.198.230:8080</li>
<li>192.168.198.231:8080</li>
</ul>
<p>应用使用tomcat部署，目前没有域名，都是使用IP在局域网中单独访问。因为没有单独的服务器可以用来部署Nginx,所以Nginx部署在229服务器上。</p>
<h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><p>在安装Nginx前，需要先安装好一些依赖包。<br><strong>gcc依赖包</strong></p>
<ul>
<li>gcc-4.8.5-16.el7.x86_64.rpm</li>
<li>glibc-devel-2.17-196.el7.x86_64.rpm</li>
<li>glibc-headers-2.17-196.el7.x86_64.rpm</li>
<li>kernel-headers-3.10.0-693.el7.x86_64.rpm</li>
</ul>
<p><strong>其它依赖包</strong></p>
<ul>
<li>pcre-devel-8.32-17.el7.x86_64.rpm</li>
<li>zlib-devel-1.2.7-17.el7.x86_64.rpm</li>
<li>openssl-fips-2.0.10.tar.gz</li>
</ul>
<p>因为无法使用yum，我下载好后通过ftp上传到服务器。依赖包下载传送门：<a href="https://centos.pkgs.org/" target="_blank" rel="noopener">https://centos.pkgs.org/</a><br>前四个为gcc安装包与相关依赖，最后一个openssl-fips如果使用rpm，还需要安装很多依赖包，因此使用压缩包安装更简单。<br><strong>gcc安装</strong><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4no3ic8j30hh0aw0z0.jpg" alt="gcc安装"><br>gcc安装验证：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nohch6j30hf06qt9d.jpg" alt="gcc验证"><br>​    </p>
<p><strong>其它依赖包安装</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@APP1 opt]# rpm -ivh pcre-devel-8.32-17.el7.x86_64.rpm </span><br><span class="line">警告：pcre-devel-8.32-17.el7.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID f4a80eb5: NOKEY</span><br><span class="line">准备中...                          ################################# [100%]</span><br><span class="line">正在升级/安装...</span><br><span class="line"></span><br><span class="line">[root@APP1 opt]# rpm -ivh zlib-devel-1.2.7-17.el7.x86_64.rpm </span><br><span class="line">警告：zlib-devel-1.2.7-17.el7.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID f4a80eb5: NOKEY</span><br><span class="line">准备中...                          ################################# [100%]</span><br><span class="line">正在升级/安装...</span><br><span class="line">   1:zlib-devel-1.2.7-17.el7          ################################# [100%]</span><br><span class="line">   </span><br><span class="line">[root@APP1 opt]# tar zxvf openssl-fips-2.0.10.tar.gz </span><br><span class="line">[root@APP1 opt]# cd openssl-fips-2.0.10/</span><br><span class="line">[root@APP1 openssl-fips-2.0.10]# ./config &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>安装好上述依赖包后就可以安装Nginx了。安装如下：<br>使用tar将nginx-1.12.0.tar.gz 解压到 /usr/local/目录，编译安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@HMDMAPP1 opt]# tar -zxvf nginx-1.12.0.tar.gz -C /usr/local/</span><br><span class="line">[root@HMDMAPP1 opt]# cd /usr/local/nginx-1.12.0/</span><br><span class="line">[root@HMDMAPP1 nginx-1.12.0]# ./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">[root@HMDMAPP1 nginx-1.12.0]# whereis nginx</span><br><span class="line">nginx: /usr/local/nginx</span><br></pre></td></tr></table></figure></p>
<h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>安装好后我们需要对Nginx进行配置。<br>配置文件路径为：/usr/local/nginx/sconf/nginx.conf<br>主要配置点：<br>1、<strong>upstream</strong><br>这里配置一组被代理的服务器地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream mysvr &#123;</span><br><span class="line">		server 192.168.198.229:8080   weight=1 max_fails=3 fail_timeout=15;</span><br><span class="line">        server 192.168.198.230:8080   weight=1 max_fails=3 fail_timeout=15;</span><br><span class="line">        server 192.168.198.231:8080   weight=1 max_fails=3 fail_timeout=15;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、<strong>server</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80; #监听端口，与应用端口不同</span><br><span class="line">        server_name  192.168.198.229; #监听地址，一般是配置域名</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://mysvr; #请求转向upstream配置中mysvr定义的服务器列表</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请求转向还有另外一种写法：<br>如果upstream 中的服务器列表地址前加了<code>http://</code> 则在server中的请求转向地址<code>mysvr</code>不需要加<code>http://</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream mysvr&#123;</span><br><span class="line">	server http://192.168.198.229:8080   weight=1 max_fails=3 fail_timeout=15;</span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">	....</span><br><span class="line">	location / &#123;</span><br><span class="line">            proxy_pass mysvr; #请求转向upstream配置中mysvr定义的服务器列表</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@HMDMAPP1 /]# cd /usr/local/nginx/sbin</span><br><span class="line">[root@HMDMAPP1 sbin]# ./nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Nginx常用命令<br> 查看进程: ps -aux |grep ‘nginx’<br> 重启nginx: ./nginx -s reopen<br> 停止nginx: ./nginx -s stop<br> 重新载入配置文件: ./nginx -s reload </p>
</blockquote>
<p>通过 192.168.198.229+应用地址 进行访问，我们可以在不同的服务器中的页面中添加标识来测试Nginx配置是否成功。下面访问test3.html页面不同刷新显示结果如下：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4no9zl4j30en02lt8s.jpg" alt="这里写图片描述"><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nod9avj30cy02mjrg.jpg" alt="这里写图片描述"><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4no7o8zj30ee02n3yk.jpg" alt="这里写图片描述"><br>可以看到访问地址没有变化，但Nginx把请求分配到了不同的服务器上。</p>
<p>本文中使用到了依赖包与Nginx.conf完整配置文件下载：<a href="https://download.csdn.net/download/ftdd_hw/10578071" target="_blank" rel="noopener">https://download.csdn.net/download/ftdd_hw/10578071</a></p>
<p>推荐学习：<a href="https://blog.csdn.net/qq_29534483/article/details/81020755" target="_blank" rel="noopener">Nginx部署与配置</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/5445b57/">Linux下Oracle常用命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Oracle/">Oracle</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Linux-Oracle/">Linux Oracle</a></span><div class="content"><h3 id="Linux下安装Oracle-11g"><a href="#Linux下安装Oracle-11g" class="headerlink" title="Linux下安装Oracle 11g"></a>Linux下安装Oracle 11g</h3><p>传送门:<br><a href="http://www.oracle.com/ocom/groups/public/@otn/documents/webcontent/229016_zhs.htm" target="_blank" rel="noopener">http://www.oracle.com/ocom/groups/public/@otn/documents/webcontent/229016_zhs.htm</a></p>
<h3 id="登陆oracle"><a href="#登陆oracle" class="headerlink" title="登陆oracle"></a>登陆oracle</h3><pre><code>&gt;su - oracle
&gt;sqlplus /nolog
</code></pre><h3 id="管理员登陆"><a href="#管理员登陆" class="headerlink" title="管理员登陆"></a>管理员登陆</h3><pre><code>&gt;conn /as sysdba
</code></pre><h3 id="用户登陆"><a href="#用户登陆" class="headerlink" title="用户登陆"></a>用户登陆</h3><pre><code>&gt;conn username/password
</code></pre><h3 id="远程用户登陆"><a href="#远程用户登陆" class="headerlink" title="远程用户登陆"></a>远程用户登陆</h3><pre><code>&gt;conn username/password@ip:1521/ORCL
</code></pre><h3 id="当前登陆用户"><a href="#当前登陆用户" class="headerlink" title="当前登陆用户"></a>当前登陆用户</h3><pre><code>&gt;show user;
</code></pre><h3 id="执行SQL文件-适合大文件"><a href="#执行SQL文件-适合大文件" class="headerlink" title="执行SQL文件(适合大文件)"></a>执行SQL文件(适合大文件)</h3><pre><code>&gt;conn user/pwd
&gt;@/路径/sql.sql;
</code></pre><h3 id="存储查询结果"><a href="#存储查询结果" class="headerlink" title="存储查询结果"></a>存储查询结果</h3><pre><code>&gt;spool d:\1.txt
&gt;select * from emp;
&gt;spool off
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/7d66ca0d/">Spring Cloud Eureka实现服务注册与发现</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/微服务/">微服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Eureka/">Eureka</a></span><div class="content"><p>目录</p>
<p>[TOC]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>服务发现组件是微服务架构中非常关键的一个组件。SpringCloud 提供的服务发现有多种，如Eureka，Consul和Zookeeper等。本篇介绍的是Eureka的使用。</p>
<h1 id="服务发现简介"><a href="#服务发现简介" class="headerlink" title="服务发现简介"></a>服务发现简介</h1><p>服务提供者，服务消费者，服务发现组件这三者之间的关系大致如下：</p>
<p><code>服务提供者与服务消费者都需要向服务发现组件进行注册，服务消费者从服务发现组件中获取服务提供者的信息(如名称、地址、端口等)。在服务发现组件注册的微服务需要通过心跳机制来保持连接状态并更新注册信息，当服务发现组件长时间无法与某个微服务实例进行通信时，会注销这个实例。这种机制使得即使服务提供者信息发生变化，服务消费者也无须修改配置文件。</code></p>
<p>由以上得知，服务发现组件应具备以下功能：</p>
<ul>
<li><p>服务注册表：用于记录各个微服务的注册信息，它还提供查询API与管理API。</p>
</li>
<li><p>服务注册与服务发现：服务注册是指微服务在启动是将自己的信息注册到服务发现组件的过程。服务发现是指查询可用的微服务列表及其网络地址的机制。</p>
</li>
<li><p>服务检查：服务发现组件应有一定的机制定时检测已注册的微服务，如长时间无法访问，就会从服务注册表中移除该实例。</p>
</li>
</ul>
<h1 id="Eureka原理"><a href="#Eureka原理" class="headerlink" title="Eureka原理"></a>Eureka原理</h1><p>以下是Eureka官方的架构图，比较详细的描述了Erueka集群的工作原理：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nyu1trj30hu0b3t97.jpg" alt="Eureka官方架构图"><br>我们可以把us-east-1c、us-east-1d与us-east-1e理解成独立的机房，而这整个图则是一个跨机房的Eureka集群。其中：</p>
<ul>
<li><p>Application Service 相当于前面说的服务提供者</p>
</li>
<li><p>Application Client 相当于前面的服务消费者</p>
</li>
<li><p>Make Remote Call 可以理解成调用RESTful API的行为</p>
</li>
</ul>
<p>由于图中所示，我们可以知道Eureka包含两个组件:Eureka Server 和 Eureka Client，它们的作用如下：</p>
<ul>
<li><p>Eureka Server提供服务发现的能力</p>
</li>
<li><p>Eureka Client 是一个java客户端，用于简化与Eureka Server的交互</p>
</li>
<li><p>微服务在启动后，会同期性（默认30s）地向Eureka Server 发送心跳来续约自己的“租期”</p>
</li>
<li><p>如果Eureka Server 在一定时间内（默认90s）没有接收到某个微服务的实例心跳，Eureka Server将会注销该实例</p>
</li>
<li><p>默认情况下，Eureka Server同时也是Eureka Client。多个Eureka Server 实例，互相之间通过复制的方式，来实现服务注册表中的数据同步</p>
</li>
<li><p>Eureka Client 会缓存服务注册表的信息，所以微服务无须每次请求都查询Eureka Server，从而降低了Eureka Server的压力。另外，即使Eureka Server 所以节点都挂了，服务消费者仍然可以使用缓存中的信息找到服务提供者并完成调用</p>
</li>
</ul>
<h1 id="Eureka-Server实现"><a href="#Eureka-Server实现" class="headerlink" title="Eureka Server实现"></a>Eureka Server实现</h1><p><strong>环境</strong></p>
<ul>
<li>Idea</li>
<li>Spring Boot ：1.5.9.RELEASE</li>
<li>Spring Cloud：Edgware.RELEASE</li>
<li>JDK ：1.8</li>
</ul>
<p><strong>引入依赖</strong><br>在Idea新建 一个Spring Boot项目，添加以下依赖：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入Eureka依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入spring cloud的依赖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>编写启动类</strong><br>我们需要在启动类上加上 <code>@EnableEurekaServer</code> 注解，声明这是一个Eureka Server<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceDiscoveryEurekaApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(MicroserviceDiscoveryEurekaApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>添加配置</strong><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">	<span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>eureka.client.register-with-eureka</code> 表示是否将自己注册到Eureka Server，默认为true,由于当前应用就是Eureka Server，所以设为false<br><code>eureka.client.fetch-registry</code> 表示是否从Eureka Server获取注册信息，默认为true,因为这是一个单点的Eureka Server，不需要同步其他的Eureka Server节点的数据，所以设定为false<br><code>eureka.client.serviceUrl.defaultZone</code> 设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址，多个地址可以使用 <code>,</code> 分隔</p>
</blockquote>
<p>启动项目，访问<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> 即可看到Eureka Server的首页。可以看到界面展示了实例的状态，可用与不可用的Eureka节点，注册的服务实例列表，常用信息等，当然，目前还没有服务向这个Server注册过，下面记录实现服务注册。</p>
<h1 id="微服务注册"><a href="#微服务注册" class="headerlink" title="微服务注册"></a>微服务注册</h1><p>Eureka Server建好后，我们的微服务就可以向这个Eureka Server进行注册了。<br>我们把之前文章(<a href="https://blog.csdn.net/ftdd_hw/article/details/80874370" target="_blank" rel="noopener">微服务简单实例–电影购票</a>)中实现的服务提供者修改一下。<br><strong>添加依赖</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册Eureka Server--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>修改配置</strong><br>在之前项目配置的基础上添加以下配置<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">microservice-provider-user</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:8761/eureka/</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>eureka.client.instance.prefer-ip-address</code>表示将自己的IP注册到Eureka Server<br><code>spring.application.name</code> 是指定一个应用名称<br><code>eureka.client.serviceUrl.defaultZone</code> 设置Eureka Server的地址，多个Eureka地址使用<code>,</code>分隔</p>
</blockquote>
<p><strong>修改启动类</strong><br>同样的，在微服务的启动类上加上一个注解 <code>@EnableDiscoveryClient</code> 表示这是一个Eureka Client。上面也说到Eureka 包含Server 与 Client两个组件，Client本身是一个JAVA客户端，把它集成到微服务中，简化了微服务与Eureka Server 的交互。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceSimpleProviderUserApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(MicroserviceSimpleProviderUserApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成以上修改后，启动服务提供者项目。刷新Eureka Server可以看到在 Instances currently registered with Eureka 栏目下出现了服务提供者的名称，地址，状态等信息。<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nwy7r9j30y504dmxo.jpg" alt="注册成功"><br>这样，一个微服务就注册到Eureka Server上了。另外如果是非JAVA服务注册到Eureka Server，可以使用Eureka的api进行注册。</p>
<h1 id="Erueka高可用部署"><a href="#Erueka高可用部署" class="headerlink" title="Erueka高可用部署"></a>Erueka高可用部署</h1><p>前面我们写了一个Eureka Server，并将一个微服务注册到了Eureka Server，在实际环境中，Eureka 需要是一个高可用的集群环境。这样Eureka Server 宕机时，其它的Eureka节点还是能够继续提供服务，虽然Eureka Client有缓存注册表信息，也可以提供服务查询，但缓存不及时更新也会影响之后的服务调用。<br>前面在编写Eureka  Server时配置了  <code>eureka.client.register-with-eureka=false</code> 和<code>eureka.client.fetch-registry=false</code>，现在在多节点的环境中，要实现Eureka实例之间相互注册彼此增量地同步信息，才能确保各节点数据一致，实现Eureka的高可用部署。所以下面的集群环境中，这两个配置应该为 <code>true</code> 或不配置默认为 <code>true</code> 。<br><strong>修改hosts</strong><br>因为是在本机实现多节点的Eureka Server集群，需要修改一下系统的hosts文件，添加以下配置：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">127.0.0.1  peer1 peer2 peer3</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如修改hosts无法保存，需要添加用户修改权限。<br>添加成功后可以ping peer1试试是否配置生效。</p>
</blockquote>
<p><strong>修改配置</strong><br>将上面编写的Eureka Server 项目的application.yml修改如下 :<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">microservice-discovery-eureka</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">peer1</span>                     <span class="comment"># 指定profile=peer1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer1</span>                   <span class="comment"># 指定当profile=peer1时，主机名是peer1</span></span><br><span class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer2:8762/eureka/,http://peer3:8763/eureka/</span>      <span class="comment"># 将自己注册到peer2和peer3这两个Eureka上面去</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">  prefer-ip-address:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:8761/eureka/,http://peer3:8763/eureka/</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">peer3</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8763</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer3</span></span><br><span class="line"><span class="attr">  prefer-ip-address:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:8761/eureka/,http://peer2:8762/eureka/</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>YAML 文件可以由一或多个文档组成（即相对独立的组织结构组成），文档间使用<code>---</code>（三个横线）在每文档开始作为分隔符。同时，文档也可以使用<code>...</code>（三个点号）作为结束符（可选）。<br>所以这里的配置文件实际上是三个配置文件组成，<code>---</code>分隔符不可少，否则编译出错。也可以把这几段配置写在三个YAML文件中。</p>
</blockquote>
<p><strong>启动</strong><br>启动项目时通过给spring.profiles.active 传递不同的参数，以使用不同的配置。<br>在IDEA中我们可以在启动前配置参数：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nynrigj30uc0l33zv.jpg" alt="这里写图片描述"><br>添加三个Spring Boot Application，并选择启动类，在Active Profiles中分别配置peer1,peer2,peer3参数后，分别启动。<br>在启动时，先启动成功的Eureka 可能会报以下错误：<br>​<br>​    2018-07-05 14:32:10.983 ERROR 13768 — [-target_peer2-8] c.n.e.cluster.ReplicationTaskProcessor   : Network level connection to peer peer2; retrying after delay<br>​    com.sun.jersey.api.client.ClientHandlerException: java.net.SocketTimeoutException: Read timed out</p>
<p>这是因为先启动成功的peer1根据配置会向peer2和peer3进行注册请求，而此时这两个应用可能还没启动好，所以出现上面的错误，三个应用启动成功后就正常了。<br>正常情况下如下图：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nx3ewhj31830m0mze.jpg" alt="Eureka集群"><br>显示了注册到该Eureka的实例信息，Eureka各节点地址。<br>在下面可以看到显示了两个注册的节点，同时这两个节点是可用的。<br>我之前测试时出现不可用(<strong>unavailable-replicas</strong>)的节点，如下：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nywz5rj30pc035q35.jpg" alt="不可用Eureka"><br><strong>解决情况是将 <code>eureka.instance.prefer-ip-address</code> 设置为 <code>false</code> ，因为是在本地配置集群环境，IP是相同的，因此使用IP注册可能会导致节点不可识别，另外，三个应用的<code>spring.application.name</code>不一致也会出现 <em>unavailable-replicas</em> 的情况</strong></p>
<p><strong>服务注册到Erueka 集群</strong><br>前面我们将服务提供者注册到了一个单节点的Eureka Server ，在Eureka的集群环境中，只需要稍加修改即可。把服务提供者的 <code>eureka.client.serviceUrl.defaultZone</code>配置修改如下:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:8761/eureka/,http://peer2:8762/eureka/,http://peer3:8763/eureka/</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>其实可以继续使用localhost，因为是在本地测试。<br>另外，我们可以只写一个Eureka Server的地址，因为各Eureka Server节点之间会自动同步注册的实例信息，正常情况下这两种方式是一样。建议全部写上。</p>
</blockquote>
<p>启动服务提供者，刷新三个Eureka Server可以看到服务已经注册了:<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nx864xj317i0jfwgj.jpg" alt="集群注册"></p>
<h1 id="Eureka用户认证"><a href="#Eureka用户认证" class="headerlink" title="Eureka用户认证"></a>Eureka用户认证</h1><p>在生产环境中Eureka Server需要登录才能访问，Eureka的用户认证可以使用Security实现。下面稍微修改一下Eureka Server<br><strong>添加依赖</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>添加配置</strong><br>添加以下配置在第一段中，作为三个Eureka Server的公共配置。<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">  basic:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span>                     <span class="comment">#开启HTTP basic的认证</span></span><br><span class="line"><span class="attr">  user:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">user</span>                        <span class="comment">#配置登录账号证</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">admin</span>                   <span class="comment">#配置登录密码</span></span><br></pre></td></tr></table></figure></p>
<p><code>最后把Eureka以及服务提供者的配置文件中的 defaultZone 地址修改成如下格式：</code></p>
<pre><code>http://user:admin@peer1:8761/eureka/
</code></pre><p>这样才能注册到需要认证的Eureka Server。</p>
<p>重新启动Eureka Server和服务提供者后，再次访问三个Eureka可以看到弹出了登录框，输入上面的账号与密码后登录后即可进行Eureka Server首页，服务已正常注册成功。</p>
<h1 id="Eureka自我保护模式"><a href="#Eureka自我保护模式" class="headerlink" title="Eureka自我保护模式"></a>Eureka自我保护模式</h1><p>在实现上面的练习过程中，打开Eureka可能会遇到如下情况：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4nz1vxdj317o0bkjsl.jpg" alt="Eureka自我保护模式"><br>这是Eureka开启自我保护模式时的警告。<br>前面说过Eureka Server在一定时间内没有接收到某个微服务实例心跳，Eureka Server将会注销该实例。但如果出现网络分区故障，微服务与Eureka Server之间无法正常通信，微服务其实是正常的，但由于无法接收到该微服务的通信，Eureka Server则会注销该服务。<br>为了避免这种情况的发生，Eureka Server 通过 自我保护模式 来解决这个问题。当Eureka Server在短时间内丢失过多客户端时，那么这个Eureka节点会进行自我保护模式。Eureka 会保护服务注册表中的信息，不再删除服务注册表中的数据，当网络故障恢复后，该Eureka节点会自动退出自我保护模式。<br>这种模式使得Eureka 集群更加健壮，稳定。<br>另外也可以选择禁用该模式，配置如下：<br>​<br>​    eureka.server.enable-self-preservation = false</p>
<h1 id="Eureka健康检查"><a href="#Eureka健康检查" class="headerlink" title="Eureka健康检查"></a>Eureka健康检查</h1><p>登录Eureka首页可以看到注册的微服务状态是 <code>UP</code><br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4ny3lqij30q104nmxz.jpg" alt="微服务状态"><br>表示应用程序状态正常，应用的状态还有其它取值，如DOWN,OUT_OF_SERVICE,UNKNOWN等。只有标记为 <code>UP</code> 的微服务会被请求。<br>默认情况下，服务器端与客户端的心跳保持正常，应用程序状态就会显示<code>UP</code> 状态。但这个机制并不能完全反应微服务的状态，举个栗子，微服务与Eureka Server心跳正常，但微服务的数据源出现了问题（如数据库被关闭）。这个微服务其实无法正常工作，但Eureka Server认为该微服务为<code>UP</code>状态。<br>为了解决这个问题，我们可以把微服务的健康状态传播到Eureka Server，只需要在微服务中作如下配置：<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    healthcheck:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>这样，当微服务健康状态出问题时，Eureka Server能够实时反应其它真实状态。</p>
<p>参考：<a href="http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html" target="_blank" rel="noopener">官方API文档</a></p>
<p>以上，为《Spring Cloud与Docker微服务架构实战》第4章学习笔记。    </p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/297fa226/">Spring Boot Actuator监控端点</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/微服务/">微服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Actuator/">Actuator</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/微服务监控端口/">微服务监控端口</a></span><div class="content"><p>目录</p>
<p>[TOC]</p>
<hr>
<p>#前言<br>微服务的这种架构虽然解决了单体应用的一些劣势，但它也面临一些挑战，比如对运维的要求更高了。一个微服务架构中可能有几十个上百个应用构成，要保证这些应用都正常运行，相互协调是比较麻烦的事情，因此我们需要一个组件来对这些应用进行监控和管理。<br><code>spring-boot-starter-actuator</code> 就是Spring Boot提供这个功能的模块。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>运行环境：</p>
<blockquote>
<p>Spring Boot 2.0.3.RELEASE</p>
</blockquote>
<p><strong>1、引入依赖</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2、启动应用</strong><br>重新启动应用访问 <code>http://localhost:8000/actuator/health</code> 会显示如下信息：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	status: "UP"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Actuator监控管理默认的访问路径是在 <code>/actuator</code> 下。在测试Spring  Boot 1.5.9版本时是直接访问端点路径，不需要加 <code>/actuator</code> </p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>除了health端点外，Actuator还为我们提供了很多端点，有些可以直接访问，有些需要授权或通过配置才能访问。</p>
<h2 id="端点列表"><a href="#端点列表" class="headerlink" title="端点列表"></a>端点列表</h2><table>
<thead>
<tr>
<th style="text-align:right">端点</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"><code>actuator</code></td>
<td style="text-align:right">为其他端点提供基于超媒体的“发现页面”。要求Spring HATEOAS在类路径上</td>
</tr>
<tr>
<td style="text-align:right"><code>auditevents</code></td>
<td style="text-align:right">公开当前应用程序的审核事件信息</td>
</tr>
<tr>
<td style="text-align:right"><code>autoconfig</code></td>
<td style="text-align:right">显示自动配置报告，显示所有自动配置候选项以及它们“未被”应用的原因</td>
</tr>
<tr>
<td style="text-align:right"><code>beans</code></td>
<td style="text-align:right">显示应用程序中所有Spring bean的完整列表</td>
</tr>
<tr>
<td style="text-align:right"><code>configprops</code></td>
<td style="text-align:right">显示所有配置信息。</td>
</tr>
<tr>
<td style="text-align:right"><code>dump</code></td>
<td style="text-align:right">打印线程栈</td>
</tr>
<tr>
<td style="text-align:right"><code>env</code></td>
<td style="text-align:right">查看所以环境变量</td>
</tr>
<tr>
<td style="text-align:right"><code>health</code></td>
<td style="text-align:right">显示应用程序运行状况信息</td>
</tr>
<tr>
<td style="text-align:right"><code>info</code></td>
<td style="text-align:right">显示应用信息</td>
</tr>
<tr>
<td style="text-align:right"><code>loggers</code></td>
<td style="text-align:right">显示和修改应用程序中记录器的配置</td>
</tr>
<tr>
<td style="text-align:right"><code>liquibase</code></td>
<td style="text-align:right">显示已应用的任何Liquibase数据库迁移</td>
</tr>
<tr>
<td style="text-align:right"><code>metrics</code></td>
<td style="text-align:right">显示当前应用程序的“指标”信息</td>
</tr>
<tr>
<td style="text-align:right"><code>mappings</code></td>
<td style="text-align:right">显示所有@RequestMapping路径的整理列表</td>
</tr>
<tr>
<td style="text-align:right"><code>shutdown</code></td>
<td style="text-align:right">允许应用程序正常关闭（默认情况下不启用）</td>
</tr>
<tr>
<td style="text-align:right"><code>trace</code></td>
<td style="text-align:right">显示跟踪信息（默认情况下是最近的100个HTTP请求</td>
</tr>
</tbody>
</table>
<h2 id="Actuator配置"><a href="#Actuator配置" class="headerlink" title="Actuator配置"></a>Actuator配置</h2><p><strong>自定义默认路径</strong><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">management.endpoints.web.base-path</span> <span class="string">=</span> <span class="string">/application</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>修改后访问端点的默认路径不再是 <code>/actuator</code> 而是 <code>/application</code></p>
</blockquote>
<p><strong>自定义访问端口号</strong><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">management.server.port=</span> <span class="number">8012</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>修改后我们查看Actuator需要修改成8012端口进行访问，如<code>http://localhost:8012/actuator/health</code></p>
</blockquote>
<p><strong>关闭验证</strong><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">management.security.enabled=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>默认情况下只开放了<code>health</code> 与 <code>info</code> 端口，关闭验证后，其它的也可以访问了，但不安全，最好添加 <code>security</code> 验证</p>
</blockquote>
<p><strong>控制端点是否开放</strong><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">management.endpoints.web.exposure.include=</span> <span class="string">'info'</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>表示只暴露<code>info</code>端口，如添加其它端口使用 <code>,</code> 分隔，暴露所有端口使用 <code>*</code></p>
</blockquote>
<p><strong>端口属性配置</strong><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">management.endpoint.端口名.属性=值</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如 <code>management.endpoint.health.show-details= always</code> 表示显示 <code>health</code>端口的详细信息，大多数端口可以这样配置。</p>
</blockquote>
<h2 id="整合Spring-Security"><a href="#整合Spring-Security" class="headerlink" title="整合Spring Security"></a>整合Spring Security</h2><p>监控端点的很多信息住信比较隐私，不能让没有权限的人随意查看，因此可以添加Srping Security进行控制。<br><strong>添加依赖</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>配置Security</strong><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    user:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">      password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>配置security后，访问端口需要进行登陆验证。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>另外还有其它的端口配置，还可以自定义端口等，这里不一一总结，以后需要时查查资料。贴上一个学习链接： <a href="http://blog.didispace.com/spring-boot-actuator-1/" target="_blank" rel="noopener">http://blog.didispace.com/spring-boot-actuator-1/</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/5a5916f3/">微服务简单实例--电影购票</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/微服务/">微服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/微服务/">微服务</a></span><div class="content"><p>目录</p>
<p>[TOC]</p>
<hr>
<p>通过上一篇文章理解了微服务后我们通过一个简单的电影购票场景来实现微服务。<br>如图：<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4n62ckwj30g502qjre.jpg" alt="电影购票系统"><br>这个场景当中，用户微服务是一个服务提供者，电影微服务是一个服务消费者，之前我们也说到，每个微服务从开发，测试，构建，部署，都应当独立运行，即每个微服务是单独的子项目。下面来实现这个场景。</p>
<h1 id="一、编写服务提供者"><a href="#一、编写服务提供者" class="headerlink" title="一、编写服务提供者"></a>一、编写服务提供者</h1><p>新建一个Spring Boot （版本1.5.9.RELEASE) 项目，不知道如何在IDEA中新建的可以看这篇&gt;&gt;传送门：：<a href="https://blog.csdn.net/ftdd_hw/article/details/76889440" target="_blank" rel="noopener">Spring Boot 入门知识</a></p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>项目使用H2作为数据库，使用jpa作为持久层框架。Spring Boot环境中H2数据库的基本配置可参考这篇&gt;&gt;传送门：<a href="https://blog.csdn.net/FTDD_HW/article/details/80696381" target="_blank" rel="noopener">Spring Boot环境下的 H2数据库基本配置</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入SpringCloud 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>application.yml 文件配置如下 ：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    generate-ddl:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line"><span class="attr">      ddl_auto:</span> <span class="string">none</span></span><br><span class="line"><span class="attr">  h2:</span></span><br><span class="line"><span class="attr">    console:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/h2-console</span>               <span class="comment">#h2 web控制台路径</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span>                   <span class="comment">#开启 Web Console</span></span><br><span class="line"><span class="attr">      settings:</span></span><br><span class="line"><span class="attr">        web-allow-others:</span> <span class="literal">true</span>        <span class="comment">#允许远程访问 Web Console</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    platform:</span> <span class="string">h2</span>                      <span class="comment">#指定数据源类型</span></span><br><span class="line"><span class="attr">    schema:</span> <span class="attr">classpath:schema.sql</span>      <span class="comment">#指定数据库的数据脚本</span></span><br><span class="line"><span class="attr">    data:</span> <span class="attr">classpath:data.sql</span>          <span class="comment">#指定数据库的数据脚本</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>spring.h2.console.path 指定了h2控制台的路径，可以通过localhost:8000/h2-console 去访问H2的控制台。<br>spring.datasource.schema 与 datasource.data 会在每次启动项目时都会被执行</p>
</blockquote>
<p><strong>schema.sql</strong><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">if</span> <span class="keyword">exists</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (<span class="keyword">id</span> <span class="built_in">bigint</span> <span class="keyword">generated</span> <span class="keyword">by</span> <span class="keyword">default</span> <span class="keyword">as</span> <span class="keyword">identity</span>, username <span class="built_in">varchar</span>(<span class="number">40</span>), <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>), age <span class="built_in">int</span>(<span class="number">3</span>), balance <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>), primary <span class="keyword">key</span> (<span class="keyword">id</span>));</span><br></pre></td></tr></table></figure></p>
<p><strong>data.sql</strong><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">id</span>, username, <span class="keyword">name</span>, age, balance) <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">'account1'</span>, <span class="string">'张三'</span>, <span class="number">20</span>, <span class="number">100.00</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">id</span>, username, <span class="keyword">name</span>, age, balance) <span class="keyword">values</span> (<span class="number">2</span>, <span class="string">'account2'</span>, <span class="string">'李四'</span>, <span class="number">28</span>, <span class="number">180.00</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">id</span>, username, <span class="keyword">name</span>, age, balance) <span class="keyword">values</span> (<span class="number">3</span>, <span class="string">'account3'</span>, <span class="string">'王一'</span>, <span class="number">32</span>, <span class="number">280.00</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="pojo"><a href="#pojo" class="headerlink" title="pojo"></a>pojo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties</span>(value=&#123;<span class="string">"hibernateLazyInitializer"</span>,<span class="string">"handler"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...get</span></span><br><span class="line"><span class="comment">//...set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>报错</strong><br>​<br>    com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.hibernate.proxy.pojo.javassist.JavassistLazyInitializer and no properties discovered to create BeanSerializer<br>如果在运行时报以上错误，则需要添加注释：<br><strong>@JsonIgnoreProperties(value={“hibernateLazyInitializer”,”handler”})</strong></p>
<blockquote>
<p>这是因为 hibernate会给每个被管理的对象加上hibernateLazyInitializer属性，jsonplugin通过java的反射机制将pojo转换成json，会把hibernateLazyInitializer也拿出来操作,但是hibernateLazyInitializer无法由反射得到，就会抛异常了。</p>
</blockquote>
<h2 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        User findOne = <span class="keyword">this</span>.userRepository.getOne(id);</span><br><span class="line">        <span class="keyword">return</span> findOne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@GetMapping() 等同于 @RequestMapping(method = {RequestMethod.GET})</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行项目，访问测试<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4n6a4wej30cm06rwen.jpg" alt="测试"></p>
<h1 id="二、编写服务消费者"><a href="#二、编写服务消费者" class="headerlink" title="二、编写服务消费者"></a>二、编写服务消费者</h1><p>消费者作为服务调用方，这里只使用最简单的方式来实现。</p>
<h2 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入SpringCloud 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p><strong>application.yml</strong><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8011</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">    userServiceUrl:</span> <span class="attr">http://localhost:8000/</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>user.userServiceUrl ：把调用地址写入配置文件</p>
</blockquote>
<h2 id="pojo-1"><a href="#pojo-1" class="headerlink" title="pojo"></a>pojo</h2><p>这里与上面的服务提供者相同</p>
<h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><p>实例化RestTemplate<br>在启动类中添加以下方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;user.userServiceUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String userServiceUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="keyword">this</span>.userServiceUrl + id,User.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里使用 restTemplate 来调用服务<br>@Value(“${user.userServiceUrl}”) 从配置文件中取user.userServiceUrl值</p>
</blockquote>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>启动项目进行测试<br><img src="https://wx4.sinaimg.cn/mw690/005RGBbLly1fwv4n66hlaj30dl06ndg2.jpg" alt="消费者测试"></p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>至此，一个简单的微服务完成！是不是觉得与我们平时写接口是差不多的，平时我们是在整个系统内部，各个功能模块之间进行接口调用，微服务则是把这些模块单独出来成为一个子系统，每个子系统提供接口给其它系统调用。<br><strong>在整个电影购票系统中</strong><br>使用单一职责原则：两个微服务只关注整个系统中单独，有界限的一部分。<br>满足服务自治原则：每个微服务具备独立的业务能力，依赖与运行环境。<br>使用了轻量级通信机制：消费者中使用了Rest 进行服务调用<br>微服务粒度：两个微服务都有明确的功能划分。</p>
<p>当然微服务不只是这么简单，还应该包括安全性，高可用性等，还需要集成其它的组件，后面会边学习边作记录。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By HJW</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>